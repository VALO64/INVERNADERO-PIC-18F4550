CCS PCH C Compiler, Version 5.025, 4770               06-dic.-23 10:58

               Filename:   D:\Oscar\TEC\Octavo_Semestre\Instrumentacion\P8_P9\P8_P9.lst

               ROM used:   8900 bytes (27%)
                           Largest free fragment is 15672
               RAM used:   45 (2%) at main() level
                           100 (5%) worst case
               Stack used: 13 locations (6 in main + 7 for interrupts)
               Stack size: 31

*
2000:  GOTO   410E
*
2008:  MOVWF  04
200A:  MOVFF  FD8,05
200E:  MOVFF  FE0,06
2012:  MOVLB  0
2014:  MOVFF  FE9,0C
2018:  MOVFF  FEA,07
201C:  MOVFF  FE1,08
2020:  MOVFF  FE2,09
2024:  MOVFF  FD9,0A
2028:  MOVFF  FDA,0B
202C:  MOVFF  FF3,12
2030:  MOVFF  FF4,13
2034:  MOVFF  FFA,14
2038:  MOVFF  FF5,15
203C:  MOVFF  FF6,16
2040:  MOVFF  FF7,17
2044:  MOVFF  00,0E
2048:  MOVFF  01,0F
204C:  MOVFF  02,10
2050:  MOVFF  03,11
2054:  BTFSS  FF2.5
2056:  GOTO   2060
205A:  BTFSC  FF2.2
205C:  GOTO   246E
2060:  BTFSS  FF2.4
2062:  GOTO   206C
2066:  BTFSC  FF2.1
2068:  GOTO   2506
206C:  BTFSS  FF0.3
206E:  GOTO   2078
2072:  BTFSC  FF0.0
2074:  GOTO   2516
2078:  BTFSS  FF2.3
207A:  GOTO   2084
207E:  BTFSC  FF2.0
2080:  GOTO   2118
2084:  MOVFF  0E,00
2088:  MOVFF  0F,01
208C:  MOVFF  10,02
2090:  MOVFF  11,03
2094:  MOVFF  0C,FE9
2098:  MOVFF  07,FEA
209C:  BSF    07.7
209E:  MOVFF  08,FE1
20A2:  MOVFF  09,FE2
20A6:  MOVFF  0A,FD9
20AA:  MOVFF  0B,FDA
20AE:  MOVFF  12,FF3
20B2:  MOVFF  13,FF4
20B6:  MOVFF  14,FFA
20BA:  MOVFF  15,FF5
20BE:  MOVFF  16,FF6
20C2:  MOVFF  17,FF7
20C6:  MOVF   04,W
20C8:  MOVFF  06,FE0
20CC:  MOVFF  05,FD8
20D0:  RETFIE 0
....................    #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
20D2:  TBLRD*+
20D4:  MOVFF  FF6,55
20D8:  MOVFF  FF7,56
20DC:  MOVF   FF5,W
20DE:  BTFSS  F9E.4
20E0:  BRA    20DE
20E2:  MOVWF  FAD
20E4:  MOVFF  55,FF6
20E8:  MOVFF  56,FF7
20EC:  DECFSZ 54,F
20EE:  BRA    20D2
20F0:  RETURN 0
*
21E2:  DATA 54,65
21E4:  DATA 63,6C
21E6:  DATA 61,3D
21E8:  DATA 20,25
21EA:  DATA 63,0D
21EC:  DATA 0A,00
*
237E:  TBLRD*+
2380:  MOVFF  FF6,55
2384:  MOVFF  FF7,56
2388:  MOVFF  FF5,5A
238C:  RCALL  232E
238E:  MOVFF  55,FF6
2392:  MOVFF  56,FF7
2396:  DECFSZ 54,F
2398:  BRA    237E
239A:  RETURN 0
239C:  MOVF   5B,W
239E:  CLRF   01
23A0:  SUBWF  5A,W
23A2:  BC    23AA
23A4:  MOVFF  5A,00
23A8:  BRA    23C2
23AA:  CLRF   00
23AC:  MOVLW  08
23AE:  MOVWF  5C
23B0:  RLCF   5A,F
23B2:  RLCF   00,F
23B4:  MOVF   5B,W
23B6:  SUBWF  00,W
23B8:  BTFSC  FD8.0
23BA:  MOVWF  00
23BC:  RLCF   01,F
23BE:  DECFSZ 5C,F
23C0:  BRA    23B0
23C2:  RETURN 0
23C4:  MOVLW  20
23C6:  BTFSS  55.4
23C8:  MOVLW  30
23CA:  MOVWF  56
23CC:  MOVFF  54,00
23D0:  BTFSS  54.7
23D2:  BRA    23E4
23D4:  COMF   00,F
23D6:  INCF   00,F
23D8:  MOVFF  00,54
23DC:  MOVLW  2D
23DE:  MOVWF  56
23E0:  BSF    55.7
23E2:  BSF    55.0
23E4:  MOVF   01,W
23E6:  MOVFF  54,5A
23EA:  MOVLW  64
23EC:  MOVWF  5B
23EE:  RCALL  239C
23F0:  MOVFF  00,54
23F4:  MOVLW  30
23F6:  ADDWF  01,W
23F8:  MOVWF  57
23FA:  MOVFF  54,5A
23FE:  MOVLW  0A
2400:  MOVWF  5B
2402:  RCALL  239C
2404:  MOVLW  30
2406:  ADDWF  00,W
2408:  MOVWF  59
240A:  MOVLW  30
240C:  ADDWF  01,W
240E:  MOVWF  58
2410:  MOVFF  56,00
2414:  MOVLW  30
2416:  SUBWF  57,W
2418:  BZ    2422
241A:  BSF    55.1
241C:  BTFSC  55.7
241E:  BSF    55.2
2420:  BRA    2446
2422:  MOVFF  56,57
2426:  MOVLW  20
2428:  MOVWF  56
242A:  MOVLW  30
242C:  SUBWF  58,W
242E:  BZ    2438
2430:  BSF    55.0
2432:  BTFSC  55.7
2434:  BSF    55.1
2436:  BRA    2446
2438:  BTFSS  FD8.2
243A:  BSF    55.0
243C:  BNZ   2446
243E:  MOVFF  57,58
2442:  MOVLW  20
2444:  MOVWF  57
2446:  BTFSC  55.2
2448:  BRA    2454
244A:  BTFSC  55.1
244C:  BRA    245A
244E:  BTFSC  55.0
2450:  BRA    2460
2452:  BRA    2466
2454:  MOVFF  56,5A
2458:  RCALL  232E
245A:  MOVFF  57,5A
245E:  RCALL  232E
2460:  MOVFF  58,5A
2464:  RCALL  232E
2466:  MOVFF  59,5A
246A:  RCALL  232E
246C:  RETURN 0
*
24F4:  DATA 0C,52
24F6:  DATA 65,6C
24F8:  DATA 6F,6A
24FA:  DATA 20,25
24FC:  DATA 64,20
24FE:  DATA 3A,25
2500:  DATA 64,20
2502:  DATA 3A,25
2504:  DATA 64,00
*
2528:  DATA 0D,0A
252A:  DATA 49,4E
252C:  DATA 53,54
252E:  DATA 52,55
2530:  DATA 4D,45
2532:  DATA 4E,54
2534:  DATA 52,41
2536:  DATA 43,49
2538:  DATA 4F,4E
253A:  DATA 2E,0D
253C:  DATA 00,00
253E:  DATA 0D,0A
2540:  DATA 31,2D
2542:  DATA 4F,70
2544:  DATA 63,69
2546:  DATA 6F,6E
2548:  DATA 20,31
254A:  DATA 20,28
254C:  DATA 49,6E
254E:  DATA 76,65
2550:  DATA 72,6E
2552:  DATA 61,64
2554:  DATA 65,72
2556:  DATA 6F,29
2558:  DATA 0D,00
255A:  DATA 0D,0A
255C:  DATA 32,2E
255E:  DATA 2D,4F
2560:  DATA 70,63
2562:  DATA 69,6F
2564:  DATA 6E,20
2566:  DATA 32,20
2568:  DATA 28,43
256A:  DATA 6F,6E
256C:  DATA 74,72
256E:  DATA 6F,6C
2570:  DATA 20,6D
2572:  DATA 61,6E
2574:  DATA 75,61
2576:  DATA 6C,20
2578:  DATA 69,6E
257A:  DATA 76,65
257C:  DATA 72,6E
257E:  DATA 61,64
2580:  DATA 65,72
2582:  DATA 6F,29
2584:  DATA 0D,00
2586:  DATA 0D,0A
2588:  DATA 33,2E
258A:  DATA 2D,4F
258C:  DATA 70,63
258E:  DATA 69,6F
2590:  DATA 6E,20
2592:  DATA 33,20
2594:  DATA 28,52
2596:  DATA 65,6C
2598:  DATA 6F,6A
259A:  DATA 29,00
259C:  DATA 0D,0A
259E:  DATA 45,6C
25A0:  DATA 69,67
25A2:  DATA 65,20
25A4:  DATA 6C,61
25A6:  DATA 20,6F
25A8:  DATA 70,63
25AA:  DATA 69,6F
25AC:  DATA 6E,20
25AE:  DATA 71,75
25B0:  DATA 65,20
25B2:  DATA 64,65
25B4:  DATA 63,65
25B6:  DATA 65,73
25B8:  DATA 20,00
25BA:  DATA 0D,0A
25BC:  DATA 49,4E
25BE:  DATA 53,54
25C0:  DATA 52,55
25C2:  DATA 4D,45
25C4:  DATA 4E,54
25C6:  DATA 41,43
25C8:  DATA 49,4F
25CA:  DATA 4E,0D
25CC:  DATA 00,00
25CE:  DATA 0D,0A
25D0:  DATA 31,2E
25D2:  DATA 2D,4F
25D4:  DATA 70,63
25D6:  DATA 69,6F
25D8:  DATA 6E,20
25DA:  DATA 31,20
25DC:  DATA 28,49
25DE:  DATA 6E,76
25E0:  DATA 65,72
25E2:  DATA 6E,61
25E4:  DATA 64,65
25E6:  DATA 72,6F
25E8:  DATA 29,0D
25EA:  DATA 00,00
25EC:  DATA 0D,0A
25EE:  DATA 32,2E
25F0:  DATA 2D,4F
25F2:  DATA 70,63
25F4:  DATA 69,6F
25F6:  DATA 6E,20
25F8:  DATA 32,20
25FA:  DATA 28,43
25FC:  DATA 6F,6E
25FE:  DATA 74,72
2600:  DATA 6F,6C
2602:  DATA 20,6D
2604:  DATA 61,6E
2606:  DATA 75,61
2608:  DATA 6C,20
260A:  DATA 69,6E
260C:  DATA 76,65
260E:  DATA 72,6E
2610:  DATA 61,64
2612:  DATA 65,72
2614:  DATA 6F,29
2616:  DATA 0D,00
2618:  DATA 0D,0A
261A:  DATA 33,2E
261C:  DATA 2D,4F
261E:  DATA 70,63
2620:  DATA 69,6F
2622:  DATA 6E,20
2624:  DATA 33,20
2626:  DATA 28,52
2628:  DATA 65,6C
262A:  DATA 6F,6A
262C:  DATA 29,00
262E:  DATA 0D,0A
2630:  DATA 45,6C
2632:  DATA 69,67
2634:  DATA 65,20
2636:  DATA 6C,61
2638:  DATA 20,6F
263A:  DATA 70,63
263C:  DATA 69,6F
263E:  DATA 6E,20
2640:  DATA 71,75
2642:  DATA 65,20
2644:  DATA 64,65
2646:  DATA 63,65
2648:  DATA 65,73
264A:  DATA 20,00
264C:  DATA 47,72
264E:  DATA 61,64
2650:  DATA 6F,73
2652:  DATA 3D,20
2654:  DATA 25,2E
2656:  DATA 31,66
2658:  DATA 0D,00
265A:  DATA 47,72
265C:  DATA 61,64
265E:  DATA 6F,73
2660:  DATA 3D,20
2662:  DATA 25,2E
2664:  DATA 31,66
2666:  DATA 0D,00
2668:  DATA 48,75
266A:  DATA 6D,65
266C:  DATA 64,61
266E:  DATA 64,3D
2670:  DATA 20,25
2672:  DATA 2E,31
2674:  DATA 66,0D
2676:  DATA 00,00
2678:  DATA 48,75
267A:  DATA 6D,65
267C:  DATA 64,61
267E:  DATA 64,3D
2680:  DATA 20,25
2682:  DATA 2E,31
2684:  DATA 66,0D
2686:  DATA 00,00
2688:  DATA 47,72
268A:  DATA 61,64
268C:  DATA 6F,73
268E:  DATA 3D,20
2690:  DATA 25,2E
2692:  DATA 31,66
2694:  DATA 0D,00
2696:  DATA 47,72
2698:  DATA 61,64
269A:  DATA 6F,73
269C:  DATA 3D,20
269E:  DATA 25,2E
26A0:  DATA 31,66
26A2:  DATA 0D,00
26A4:  DATA 48,75
26A6:  DATA 6D,65
26A8:  DATA 64,61
26AA:  DATA 64,3D
26AC:  DATA 20,25
26AE:  DATA 2E,31
26B0:  DATA 66,0D
26B2:  DATA 00,00
26B4:  DATA 48,75
26B6:  DATA 6D,65
26B8:  DATA 64,61
26BA:  DATA 64,3D
26BC:  DATA 20,25
26BE:  DATA 2E,31
26C0:  DATA 66,0D
26C2:  DATA 00,00
26C4:  DATA 47,72
26C6:  DATA 61,64
26C8:  DATA 6F,73
26CA:  DATA 3D,20
26CC:  DATA 25,2E
26CE:  DATA 31,66
26D0:  DATA 0D,00
26D2:  DATA 47,72
26D4:  DATA 61,64
26D6:  DATA 6F,73
26D8:  DATA 3D,20
26DA:  DATA 25,2E
26DC:  DATA 31,66
26DE:  DATA 0D,00
26E0:  DATA 48,75
26E2:  DATA 6D,65
26E4:  DATA 64,61
26E6:  DATA 64,3D
26E8:  DATA 20,25
26EA:  DATA 2E,31
26EC:  DATA 66,0D
26EE:  DATA 00,00
26F0:  DATA 48,75
26F2:  DATA 6D,65
26F4:  DATA 64,61
26F6:  DATA 64,3D
26F8:  DATA 20,25
26FA:  DATA 2E,31
26FC:  DATA 66,0D
26FE:  DATA 00,00
2700:  DATA 47,72
2702:  DATA 61,64
2704:  DATA 6F,73
2706:  DATA 3D,20
2708:  DATA 25,2E
270A:  DATA 31,66
270C:  DATA 0D,00
270E:  DATA 47,72
2710:  DATA 61,64
2712:  DATA 6F,73
2714:  DATA 3D,20
2716:  DATA 25,2E
2718:  DATA 31,66
271A:  DATA 0D,00
271C:  DATA 48,75
271E:  DATA 6D,65
2720:  DATA 64,61
2722:  DATA 64,3D
2724:  DATA 20,25
2726:  DATA 2E,31
2728:  DATA 66,0D
272A:  DATA 00,00
272C:  DATA 48,75
272E:  DATA 6D,65
2730:  DATA 64,61
2732:  DATA 64,3D
2734:  DATA 20,25
2736:  DATA 2E,31
2738:  DATA 66,0D
273A:  DATA 00,00
273C:  DATA 0A,0D
273E:  DATA 43,4F
2740:  DATA 4E,54
2742:  DATA 52,4F
2744:  DATA 4C,20
2746:  DATA 4D,41
2748:  DATA 4E,55
274A:  DATA 41,4C
274C:  DATA 20,49
274E:  DATA 4E,56
2750:  DATA 45,52
2752:  DATA 4E,41
2754:  DATA 44,45
2756:  DATA 52,4F
2758:  DATA 00,00
275A:  DATA 0A,0D
275C:  DATA 20,31
275E:  DATA 29,20
2760:  DATA 56,65
2762:  DATA 6E,74
2764:  DATA 69,6C
2766:  DATA 61,64
2768:  DATA 6F,72
276A:  DATA 00,00
276C:  DATA 0A,0D
276E:  DATA 20,32
2770:  DATA 29,20
2772:  DATA 43,61
2774:  DATA 6C,65
2776:  DATA 66,61
2778:  DATA 63,74
277A:  DATA 6F,72
277C:  DATA 00,00
277E:  DATA 0A,0D
2780:  DATA 20,33
2782:  DATA 29,20
2784:  DATA 42,6F
2786:  DATA 6D,62
2788:  DATA 61,00
278A:  DATA 0A,0D
278C:  DATA 20,34
278E:  DATA 29,20
2790:  DATA 56,65
2792:  DATA 6E,74
2794:  DATA 69,6C
2796:  DATA 61,64
2798:  DATA 6F,72
279A:  DATA 2F,42
279C:  DATA 6F,6D
279E:  DATA 62,61
27A0:  DATA 00,00
27A2:  DATA 0A,0D
27A4:  DATA 20,35
27A6:  DATA 29,20
27A8:  DATA 43,61
27AA:  DATA 6C,65
27AC:  DATA 66,61
27AE:  DATA 63,74
27B0:  DATA 6F,72
27B2:  DATA 2F,42
27B4:  DATA 6F,6D
27B6:  DATA 62,61
27B8:  DATA 00,00
27BA:  DATA 0A,0D
27BC:  DATA 20,36
27BE:  DATA 29,20
27C0:  DATA 41,70
27C2:  DATA 61,67
27C4:  DATA 61,72
27C6:  DATA 20,74
27C8:  DATA 6F,64
27CA:  DATA 6F,00
27CC:  DATA 0A,0D
27CE:  DATA 20,38
27D0:  DATA 29,20
27D2:  DATA 53,61
27D4:  DATA 6C,69
27D6:  DATA 72,00
27D8:  DATA 0A,0A
27DA:  DATA 0D,20
27DC:  DATA 51,75
27DE:  DATA 65,20
27E0:  DATA 64,65
27E2:  DATA 73,65
27E4:  DATA 61,73
27E6:  DATA 20,61
27E8:  DATA 63,74
27EA:  DATA 69,76
27EC:  DATA 61,72
27EE:  DATA 3F,20
27F0:  DATA 00,00
27F2:  TBLRD*+
27F4:  MOVF   FF5,F
27F6:  BZ    2812
27F8:  MOVFF  FF6,2C
27FC:  MOVFF  FF7,2D
2800:  MOVF   FF5,W
2802:  BTFSS  F9E.4
2804:  BRA    2802
2806:  MOVWF  FAD
2808:  MOVFF  2C,FF6
280C:  MOVFF  2D,FF7
2810:  BRA    27F2
2812:  RETURN 0
2814:  MOVLW  8E
2816:  MOVWF  00
2818:  MOVFF  3B,01
281C:  MOVFF  3A,02
2820:  CLRF   03
2822:  MOVF   01,F
2824:  BNZ   2838
2826:  MOVFF  02,01
282A:  CLRF   02
282C:  MOVLW  08
282E:  SUBWF  00,F
2830:  MOVF   01,F
2832:  BNZ   2838
2834:  CLRF   00
2836:  BRA    2848
2838:  BCF    FD8.0
283A:  BTFSC  01.7
283C:  BRA    2846
283E:  RLCF   02,F
2840:  RLCF   01,F
2842:  DECF   00,F
2844:  BRA    2838
2846:  BCF    01.7
2848:  RETURN 0
284A:  MOVF   47,W
284C:  BTFSC  FD8.2
284E:  BRA    2932
2850:  MOVWF  00
2852:  MOVF   4B,W
2854:  BTFSC  FD8.2
2856:  BRA    2932
2858:  ADDWF  00,F
285A:  BNC   2864
285C:  MOVLW  81
285E:  ADDWF  00,F
2860:  BC    2932
2862:  BRA    286C
2864:  MOVLW  7F
2866:  SUBWF  00,F
2868:  BNC   2932
286A:  BZ    2932
286C:  MOVFF  48,4F
2870:  MOVF   4C,W
2872:  XORWF  4F,F
2874:  BSF    48.7
2876:  BSF    4C.7
2878:  MOVF   4A,W
287A:  MULWF  4E
287C:  MOVFF  FF4,51
2880:  MOVF   49,W
2882:  MULWF  4D
2884:  MOVFF  FF4,03
2888:  MOVFF  FF3,50
288C:  MULWF  4E
288E:  MOVF   FF3,W
2890:  ADDWF  51,F
2892:  MOVF   FF4,W
2894:  ADDWFC 50,F
2896:  MOVLW  00
2898:  ADDWFC 03,F
289A:  MOVF   4A,W
289C:  MULWF  4D
289E:  MOVF   FF3,W
28A0:  ADDWF  51,F
28A2:  MOVF   FF4,W
28A4:  ADDWFC 50,F
28A6:  MOVLW  00
28A8:  CLRF   02
28AA:  ADDWFC 03,F
28AC:  ADDWFC 02,F
28AE:  MOVF   48,W
28B0:  MULWF  4E
28B2:  MOVF   FF3,W
28B4:  ADDWF  50,F
28B6:  MOVF   FF4,W
28B8:  ADDWFC 03,F
28BA:  MOVLW  00
28BC:  ADDWFC 02,F
28BE:  MOVF   48,W
28C0:  MULWF  4D
28C2:  MOVF   FF3,W
28C4:  ADDWF  03,F
28C6:  MOVF   FF4,W
28C8:  ADDWFC 02,F
28CA:  MOVLW  00
28CC:  CLRF   01
28CE:  ADDWFC 01,F
28D0:  MOVF   4A,W
28D2:  MULWF  4C
28D4:  MOVF   FF3,W
28D6:  ADDWF  50,F
28D8:  MOVF   FF4,W
28DA:  ADDWFC 03,F
28DC:  MOVLW  00
28DE:  ADDWFC 02,F
28E0:  ADDWFC 01,F
28E2:  MOVF   49,W
28E4:  MULWF  4C
28E6:  MOVF   FF3,W
28E8:  ADDWF  03,F
28EA:  MOVF   FF4,W
28EC:  ADDWFC 02,F
28EE:  MOVLW  00
28F0:  ADDWFC 01,F
28F2:  MOVF   48,W
28F4:  MULWF  4C
28F6:  MOVF   FF3,W
28F8:  ADDWF  02,F
28FA:  MOVF   FF4,W
28FC:  ADDWFC 01,F
28FE:  INCF   00,F
2900:  BTFSC  01.7
2902:  BRA    290E
2904:  RLCF   50,F
2906:  RLCF   03,F
2908:  RLCF   02,F
290A:  RLCF   01,F
290C:  DECF   00,F
290E:  MOVLW  00
2910:  BTFSS  50.7
2912:  BRA    2928
2914:  INCF   03,F
2916:  ADDWFC 02,F
2918:  ADDWFC 01,F
291A:  MOVF   01,W
291C:  BNZ   2928
291E:  MOVF   02,W
2920:  BNZ   2928
2922:  MOVF   03,W
2924:  BNZ   2928
2926:  INCF   00,F
2928:  BTFSC  4F.7
292A:  BSF    01.7
292C:  BTFSS  4F.7
292E:  BCF    01.7
2930:  BRA    293A
2932:  CLRF   00
2934:  CLRF   01
2936:  CLRF   02
2938:  CLRF   03
293A:  RETURN 0
293C:  MOVF   3E,W
293E:  BTFSC  FD8.2
2940:  BRA    2A8C
2942:  MOVWF  4A
2944:  MOVF   42,W
2946:  BTFSC  FD8.2
2948:  BRA    2A8C
294A:  SUBWF  4A,F
294C:  BNC   2958
294E:  MOVLW  7F
2950:  ADDWF  4A,F
2952:  BTFSC  FD8.0
2954:  BRA    2A8C
2956:  BRA    2964
2958:  MOVLW  81
295A:  SUBWF  4A,F
295C:  BTFSS  FD8.0
295E:  BRA    2A8C
2960:  BTFSC  FD8.2
2962:  BRA    2A8C
2964:  MOVFF  4A,00
2968:  CLRF   01
296A:  CLRF   02
296C:  CLRF   03
296E:  CLRF   49
2970:  MOVFF  3F,48
2974:  BSF    48.7
2976:  MOVFF  40,47
297A:  MOVFF  41,46
297E:  MOVLW  19
2980:  MOVWF  4A
2982:  MOVF   45,W
2984:  SUBWF  46,F
2986:  BC    29A2
2988:  MOVLW  01
298A:  SUBWF  47,F
298C:  BC    29A2
298E:  SUBWF  48,F
2990:  BC    29A2
2992:  SUBWF  49,F
2994:  BC    29A2
2996:  INCF   49,F
2998:  INCF   48,F
299A:  INCF   47,F
299C:  MOVF   45,W
299E:  ADDWF  46,F
29A0:  BRA    29F2
29A2:  MOVF   44,W
29A4:  SUBWF  47,F
29A6:  BC    29CC
29A8:  MOVLW  01
29AA:  SUBWF  48,F
29AC:  BC    29CC
29AE:  SUBWF  49,F
29B0:  BC    29CC
29B2:  INCF   49,F
29B4:  INCF   48,F
29B6:  MOVF   44,W
29B8:  ADDWF  47,F
29BA:  MOVF   45,W
29BC:  ADDWF  46,F
29BE:  BNC   29F2
29C0:  INCF   47,F
29C2:  BNZ   29F2
29C4:  INCF   48,F
29C6:  BNZ   29F2
29C8:  INCF   49,F
29CA:  BRA    29F2
29CC:  MOVF   43,W
29CE:  IORLW  80
29D0:  SUBWF  48,F
29D2:  BC    29F0
29D4:  MOVLW  01
29D6:  SUBWF  49,F
29D8:  BC    29F0
29DA:  INCF   49,F
29DC:  MOVF   43,W
29DE:  IORLW  80
29E0:  ADDWF  48,F
29E2:  MOVF   44,W
29E4:  ADDWF  47,F
29E6:  BNC   29BA
29E8:  INCF   48,F
29EA:  BNZ   29BA
29EC:  INCF   49,F
29EE:  BRA    29BA
29F0:  BSF    03.0
29F2:  DECFSZ 4A,F
29F4:  BRA    29F8
29F6:  BRA    2A0E
29F8:  BCF    FD8.0
29FA:  RLCF   46,F
29FC:  RLCF   47,F
29FE:  RLCF   48,F
2A00:  RLCF   49,F
2A02:  BCF    FD8.0
2A04:  RLCF   03,F
2A06:  RLCF   02,F
2A08:  RLCF   01,F
2A0A:  RLCF   4B,F
2A0C:  BRA    2982
2A0E:  BTFSS  4B.0
2A10:  BRA    2A1E
2A12:  BCF    FD8.0
2A14:  RRCF   01,F
2A16:  RRCF   02,F
2A18:  RRCF   03,F
2A1A:  RRCF   4B,F
2A1C:  BRA    2A22
2A1E:  DECF   00,F
2A20:  BZ    2A8C
2A22:  BTFSC  4B.7
2A24:  BRA    2A62
2A26:  BCF    FD8.0
2A28:  RLCF   46,F
2A2A:  RLCF   47,F
2A2C:  RLCF   48,F
2A2E:  RLCF   49,F
2A30:  MOVF   45,W
2A32:  SUBWF  46,F
2A34:  BC    2A44
2A36:  MOVLW  01
2A38:  SUBWF  47,F
2A3A:  BC    2A44
2A3C:  SUBWF  48,F
2A3E:  BC    2A44
2A40:  SUBWF  49,F
2A42:  BNC   2A78
2A44:  MOVF   44,W
2A46:  SUBWF  47,F
2A48:  BC    2A54
2A4A:  MOVLW  01
2A4C:  SUBWF  48,F
2A4E:  BC    2A54
2A50:  SUBWF  49,F
2A52:  BNC   2A78
2A54:  MOVF   43,W
2A56:  IORLW  80
2A58:  SUBWF  48,F
2A5A:  BC    2A62
2A5C:  MOVLW  01
2A5E:  SUBWF  49,F
2A60:  BNC   2A78
2A62:  INCF   03,F
2A64:  BNZ   2A78
2A66:  INCF   02,F
2A68:  BNZ   2A78
2A6A:  INCF   01,F
2A6C:  BNZ   2A78
2A6E:  INCF   00,F
2A70:  BZ    2A8C
2A72:  RRCF   01,F
2A74:  RRCF   02,F
2A76:  RRCF   03,F
2A78:  MOVFF  3F,4A
2A7C:  MOVF   43,W
2A7E:  XORWF  4A,F
2A80:  BTFSS  4A.7
2A82:  BRA    2A88
2A84:  BSF    01.7
2A86:  BRA    2A94
2A88:  BCF    01.7
2A8A:  BRA    2A94
2A8C:  CLRF   00
2A8E:  CLRF   01
2A90:  CLRF   02
2A92:  CLRF   03
2A94:  RETURN 0
2A96:  MOVLW  80
2A98:  BTFSC  FD8.1
2A9A:  XORWF  43,F
2A9C:  CLRF   48
2A9E:  CLRF   49
2AA0:  MOVFF  3F,47
2AA4:  MOVF   43,W
2AA6:  XORWF  47,F
2AA8:  MOVF   3E,W
2AAA:  BTFSC  FD8.2
2AAC:  BRA    2C66
2AAE:  MOVWF  46
2AB0:  MOVWF  00
2AB2:  MOVF   42,W
2AB4:  BTFSC  FD8.2
2AB6:  BRA    2C78
2AB8:  SUBWF  46,F
2ABA:  BTFSC  FD8.2
2ABC:  BRA    2BC0
2ABE:  BNC   2B3A
2AC0:  MOVFF  43,4C
2AC4:  BSF    4C.7
2AC6:  MOVFF  44,4B
2ACA:  MOVFF  45,4A
2ACE:  CLRF   49
2AD0:  BCF    FD8.0
2AD2:  RRCF   4C,F
2AD4:  RRCF   4B,F
2AD6:  RRCF   4A,F
2AD8:  RRCF   49,F
2ADA:  DECFSZ 46,F
2ADC:  BRA    2ACE
2ADE:  BTFSS  47.7
2AE0:  BRA    2AE8
2AE2:  BSF    48.0
2AE4:  BRA    2CA0
2AE6:  BCF    48.0
2AE8:  BCF    46.0
2AEA:  BSF    48.4
2AEC:  CLRF   FEA
2AEE:  MOVLW  41
2AF0:  MOVWF  FE9
2AF2:  BRA    2CC6
2AF4:  BCF    48.4
2AF6:  BTFSC  47.7
2AF8:  BRA    2B0E
2AFA:  BTFSS  46.0
2AFC:  BRA    2B24
2AFE:  RRCF   4C,F
2B00:  RRCF   4B,F
2B02:  RRCF   4A,F
2B04:  RRCF   49,F
2B06:  INCF   00,F
2B08:  BTFSC  FD8.2
2B0A:  BRA    2C96
2B0C:  BRA    2B24
2B0E:  BTFSC  4C.7
2B10:  BRA    2B2A
2B12:  BCF    FD8.0
2B14:  RLCF   49,F
2B16:  RLCF   4A,F
2B18:  RLCF   4B,F
2B1A:  RLCF   4C,F
2B1C:  DECF   00,F
2B1E:  BTFSC  FD8.2
2B20:  BRA    2C96
2B22:  BRA    2B0E
2B24:  BSF    48.6
2B26:  BRA    2BFE
2B28:  BCF    48.6
2B2A:  MOVFF  3F,47
2B2E:  BTFSS  3F.7
2B30:  BRA    2B36
2B32:  BSF    4C.7
2B34:  BRA    2C88
2B36:  BCF    4C.7
2B38:  BRA    2C88
2B3A:  MOVFF  42,46
2B3E:  MOVFF  42,00
2B42:  MOVF   3E,W
2B44:  SUBWF  46,F
2B46:  MOVFF  3F,4C
2B4A:  BSF    4C.7
2B4C:  MOVFF  40,4B
2B50:  MOVFF  41,4A
2B54:  CLRF   49
2B56:  BCF    FD8.0
2B58:  RRCF   4C,F
2B5A:  RRCF   4B,F
2B5C:  RRCF   4A,F
2B5E:  RRCF   49,F
2B60:  DECFSZ 46,F
2B62:  BRA    2B54
2B64:  BTFSS  47.7
2B66:  BRA    2B6E
2B68:  BSF    48.1
2B6A:  BRA    2CA0
2B6C:  BCF    48.1
2B6E:  BCF    46.0
2B70:  BSF    48.5
2B72:  CLRF   FEA
2B74:  MOVLW  45
2B76:  MOVWF  FE9
2B78:  BRA    2CC6
2B7A:  BCF    48.5
2B7C:  BTFSC  47.7
2B7E:  BRA    2B94
2B80:  BTFSS  46.0
2B82:  BRA    2BAA
2B84:  RRCF   4C,F
2B86:  RRCF   4B,F
2B88:  RRCF   4A,F
2B8A:  RRCF   49,F
2B8C:  INCF   00,F
2B8E:  BTFSC  FD8.2
2B90:  BRA    2C96
2B92:  BRA    2BAA
2B94:  BTFSC  4C.7
2B96:  BRA    2BB0
2B98:  BCF    FD8.0
2B9A:  RLCF   49,F
2B9C:  RLCF   4A,F
2B9E:  RLCF   4B,F
2BA0:  RLCF   4C,F
2BA2:  DECF   00,F
2BA4:  BTFSC  FD8.2
2BA6:  BRA    2C96
2BA8:  BRA    2B94
2BAA:  BSF    48.7
2BAC:  BRA    2BFE
2BAE:  BCF    48.7
2BB0:  MOVFF  43,47
2BB4:  BTFSS  43.7
2BB6:  BRA    2BBC
2BB8:  BSF    4C.7
2BBA:  BRA    2C88
2BBC:  BCF    4C.7
2BBE:  BRA    2C88
2BC0:  MOVFF  43,4C
2BC4:  BSF    4C.7
2BC6:  MOVFF  44,4B
2BCA:  MOVFF  45,4A
2BCE:  BTFSS  47.7
2BD0:  BRA    2BDA
2BD2:  BCF    4C.7
2BD4:  BSF    48.2
2BD6:  BRA    2CA0
2BD8:  BCF    48.2
2BDA:  CLRF   49
2BDC:  BCF    46.0
2BDE:  CLRF   FEA
2BE0:  MOVLW  41
2BE2:  MOVWF  FE9
2BE4:  BRA    2CC6
2BE6:  BTFSC  47.7
2BE8:  BRA    2C22
2BEA:  MOVFF  3F,47
2BEE:  BTFSS  46.0
2BF0:  BRA    2BFE
2BF2:  RRCF   4C,F
2BF4:  RRCF   4B,F
2BF6:  RRCF   4A,F
2BF8:  RRCF   49,F
2BFA:  INCF   00,F
2BFC:  BZ    2C96
2BFE:  BTFSS  49.7
2C00:  BRA    2C18
2C02:  INCF   4A,F
2C04:  BNZ   2C18
2C06:  INCF   4B,F
2C08:  BNZ   2C18
2C0A:  INCF   4C,F
2C0C:  BNZ   2C18
2C0E:  RRCF   4C,F
2C10:  RRCF   4B,F
2C12:  RRCF   4A,F
2C14:  INCF   00,F
2C16:  BZ    2C96
2C18:  BTFSC  48.6
2C1A:  BRA    2B28
2C1C:  BTFSC  48.7
2C1E:  BRA    2BAE
2C20:  BRA    2C5A
2C22:  MOVLW  80
2C24:  XORWF  4C,F
2C26:  BTFSS  4C.7
2C28:  BRA    2C32
2C2A:  BRA    2CA0
2C2C:  MOVFF  43,47
2C30:  BRA    2C46
2C32:  MOVFF  3F,47
2C36:  MOVF   4C,F
2C38:  BNZ   2C46
2C3A:  MOVF   4B,F
2C3C:  BNZ   2C46
2C3E:  MOVF   4A,F
2C40:  BNZ   2C46
2C42:  CLRF   00
2C44:  BRA    2C88
2C46:  BTFSC  4C.7
2C48:  BRA    2C5A
2C4A:  BCF    FD8.0
2C4C:  RLCF   49,F
2C4E:  RLCF   4A,F
2C50:  RLCF   4B,F
2C52:  RLCF   4C,F
2C54:  DECFSZ 00,F
2C56:  BRA    2C46
2C58:  BRA    2C96
2C5A:  BTFSS  47.7
2C5C:  BRA    2C62
2C5E:  BSF    4C.7
2C60:  BRA    2C88
2C62:  BCF    4C.7
2C64:  BRA    2C88
2C66:  MOVFF  42,00
2C6A:  MOVFF  43,4C
2C6E:  MOVFF  44,4B
2C72:  MOVFF  45,4A
2C76:  BRA    2C88
2C78:  MOVFF  3E,00
2C7C:  MOVFF  3F,4C
2C80:  MOVFF  40,4B
2C84:  MOVFF  41,4A
2C88:  MOVFF  4C,01
2C8C:  MOVFF  4B,02
2C90:  MOVFF  4A,03
2C94:  BRA    2CFE
2C96:  CLRF   00
2C98:  CLRF   01
2C9A:  CLRF   02
2C9C:  CLRF   03
2C9E:  BRA    2CFE
2CA0:  CLRF   49
2CA2:  COMF   4A,F
2CA4:  COMF   4B,F
2CA6:  COMF   4C,F
2CA8:  COMF   49,F
2CAA:  INCF   49,F
2CAC:  BNZ   2CB8
2CAE:  INCF   4A,F
2CB0:  BNZ   2CB8
2CB2:  INCF   4B,F
2CB4:  BNZ   2CB8
2CB6:  INCF   4C,F
2CB8:  BTFSC  48.0
2CBA:  BRA    2AE6
2CBC:  BTFSC  48.1
2CBE:  BRA    2B6C
2CC0:  BTFSC  48.2
2CC2:  BRA    2BD8
2CC4:  BRA    2C2C
2CC6:  MOVF   FEF,W
2CC8:  ADDWF  4A,F
2CCA:  BNC   2CD6
2CCC:  INCF   4B,F
2CCE:  BNZ   2CD6
2CD0:  INCF   4C,F
2CD2:  BTFSC  FD8.2
2CD4:  BSF    46.0
2CD6:  MOVF   FED,F
2CD8:  MOVF   FEF,W
2CDA:  ADDWF  4B,F
2CDC:  BNC   2CE4
2CDE:  INCF   4C,F
2CE0:  BTFSC  FD8.2
2CE2:  BSF    46.0
2CE4:  MOVF   FED,F
2CE6:  MOVF   FEF,W
2CE8:  BTFSC  FEF.7
2CEA:  BRA    2CEE
2CEC:  XORLW  80
2CEE:  ADDWF  4C,F
2CF0:  BTFSC  FD8.0
2CF2:  BSF    46.0
2CF4:  BTFSC  48.4
2CF6:  BRA    2AF4
2CF8:  BTFSC  48.5
2CFA:  BRA    2B7A
2CFC:  BRA    2BE6
2CFE:  RETURN 0
2D00:  MOVF   47,W
2D02:  SUBLW  B6
2D04:  MOVWF  47
2D06:  CLRF   03
2D08:  MOVFF  48,4B
2D0C:  BSF    48.7
2D0E:  BCF    FD8.0
2D10:  RRCF   48,F
2D12:  RRCF   49,F
2D14:  RRCF   4A,F
2D16:  RRCF   03,F
2D18:  RRCF   02,F
2D1A:  RRCF   01,F
2D1C:  RRCF   00,F
2D1E:  DECFSZ 47,F
2D20:  BRA    2D0E
2D22:  BTFSS  4B.7
2D24:  BRA    2D3C
2D26:  COMF   00,F
2D28:  COMF   01,F
2D2A:  COMF   02,F
2D2C:  COMF   03,F
2D2E:  INCF   00,F
2D30:  BTFSC  FD8.2
2D32:  INCF   01,F
2D34:  BTFSC  FD8.2
2D36:  INCF   02,F
2D38:  BTFSC  FD8.2
2D3A:  INCF   03,F
2D3C:  RETURN 0
2D3E:  BTFSC  FD8.1
2D40:  BRA    2D48
2D42:  CLRF   FEA
2D44:  MOVLW  4F
2D46:  MOVWF  FE9
2D48:  CLRF   00
2D4A:  CLRF   01
2D4C:  CLRF   02
2D4E:  CLRF   03
2D50:  CLRF   4F
2D52:  CLRF   50
2D54:  CLRF   51
2D56:  CLRF   52
2D58:  MOVF   4E,W
2D5A:  IORWF  4D,W
2D5C:  IORWF  4C,W
2D5E:  IORWF  4B,W
2D60:  BZ    2DBA
2D62:  MOVLW  20
2D64:  MOVWF  53
2D66:  BCF    FD8.0
2D68:  RLCF   47,F
2D6A:  RLCF   48,F
2D6C:  RLCF   49,F
2D6E:  RLCF   4A,F
2D70:  RLCF   4F,F
2D72:  RLCF   50,F
2D74:  RLCF   51,F
2D76:  RLCF   52,F
2D78:  MOVF   4E,W
2D7A:  SUBWF  52,W
2D7C:  BNZ   2D8E
2D7E:  MOVF   4D,W
2D80:  SUBWF  51,W
2D82:  BNZ   2D8E
2D84:  MOVF   4C,W
2D86:  SUBWF  50,W
2D88:  BNZ   2D8E
2D8A:  MOVF   4B,W
2D8C:  SUBWF  4F,W
2D8E:  BNC   2DAE
2D90:  MOVF   4B,W
2D92:  SUBWF  4F,F
2D94:  MOVF   4C,W
2D96:  BTFSS  FD8.0
2D98:  INCFSZ 4C,W
2D9A:  SUBWF  50,F
2D9C:  MOVF   4D,W
2D9E:  BTFSS  FD8.0
2DA0:  INCFSZ 4D,W
2DA2:  SUBWF  51,F
2DA4:  MOVF   4E,W
2DA6:  BTFSS  FD8.0
2DA8:  INCFSZ 4E,W
2DAA:  SUBWF  52,F
2DAC:  BSF    FD8.0
2DAE:  RLCF   00,F
2DB0:  RLCF   01,F
2DB2:  RLCF   02,F
2DB4:  RLCF   03,F
2DB6:  DECFSZ 53,F
2DB8:  BRA    2D66
2DBA:  MOVFF  4F,FEF
2DBE:  MOVFF  50,FEC
2DC2:  MOVFF  51,FEC
2DC6:  MOVFF  52,FEC
2DCA:  RETURN 0
2DCC:  MOVF   FE9,W
2DCE:  MOVWF  3F
2DD0:  MOVF   3E,W
2DD2:  MOVWF  41
2DD4:  BZ    2E08
2DD6:  MOVFF  3D,4A
2DDA:  MOVFF  3C,49
2DDE:  MOVFF  3B,48
2DE2:  MOVFF  3A,47
2DE6:  CLRF   4E
2DE8:  CLRF   4D
2DEA:  MOVLW  20
2DEC:  MOVWF  4C
2DEE:  MOVLW  82
2DF0:  MOVWF  4B
2DF2:  RCALL  284A
2DF4:  MOVFF  03,3D
2DF8:  MOVFF  02,3C
2DFC:  MOVFF  01,3B
2E00:  MOVFF  00,3A
2E04:  DECFSZ 41,F
2E06:  BRA    2DD6
2E08:  MOVFF  3D,4A
2E0C:  MOVFF  3C,49
2E10:  MOVFF  3B,48
2E14:  MOVFF  3A,47
2E18:  RCALL  2D00
2E1A:  MOVFF  03,3D
2E1E:  MOVFF  02,3C
2E22:  MOVFF  01,3B
2E26:  MOVFF  00,3A
2E2A:  BTFSS  3D.7
2E2C:  BRA    2E48
2E2E:  DECF   3F,F
2E30:  BSF    3F.5
2E32:  COMF   3A,F
2E34:  COMF   3B,F
2E36:  COMF   3C,F
2E38:  COMF   3D,F
2E3A:  INCF   3A,F
2E3C:  BTFSC  FD8.2
2E3E:  INCF   3B,F
2E40:  BTFSC  FD8.2
2E42:  INCF   3C,F
2E44:  BTFSC  FD8.2
2E46:  INCF   3D,F
2E48:  MOVLW  3B
2E4A:  MOVWF  46
2E4C:  MOVLW  9A
2E4E:  MOVWF  45
2E50:  MOVLW  CA
2E52:  MOVWF  44
2E54:  CLRF   43
2E56:  MOVLW  0A
2E58:  MOVWF  41
2E5A:  MOVF   3E,W
2E5C:  BTFSC  FD8.2
2E5E:  INCF   3F,F
2E60:  BSF    FD8.1
2E62:  CLRF   FEA
2E64:  MOVLW  3A
2E66:  MOVWF  FE9
2E68:  MOVFF  3D,4A
2E6C:  MOVFF  3C,49
2E70:  MOVFF  3B,48
2E74:  MOVFF  3A,47
2E78:  MOVFF  46,4E
2E7C:  MOVFF  45,4D
2E80:  MOVFF  44,4C
2E84:  MOVFF  43,4B
2E88:  RCALL  2D3E
2E8A:  MOVF   01,W
2E8C:  MOVF   00,F
2E8E:  BNZ   2EAE
2E90:  INCF   3E,W
2E92:  SUBWF  41,W
2E94:  BZ    2EAE
2E96:  MOVF   3F,W
2E98:  BZ    2EB2
2E9A:  ANDLW  0F
2E9C:  SUBWF  41,W
2E9E:  BZ    2EA2
2EA0:  BC    2F18
2EA2:  BTFSC  3F.7
2EA4:  BRA    2F18
2EA6:  BTFSC  3F.6
2EA8:  BRA    2EB2
2EAA:  MOVLW  20
2EAC:  BRA    2F0E
2EAE:  MOVLW  20
2EB0:  ANDWF  3F,F
2EB2:  BTFSS  3F.5
2EB4:  BRA    2ED0
2EB6:  BCF    3F.5
2EB8:  MOVF   3E,W
2EBA:  BTFSS  FD8.2
2EBC:  DECF   3F,F
2EBE:  MOVF   00,W
2EC0:  MOVWF  3F
2EC2:  MOVLW  2D
2EC4:  BTFSS  F9E.4
2EC6:  BRA    2EC4
2EC8:  MOVWF  FAD
2ECA:  MOVF   3F,W
2ECC:  MOVWF  00
2ECE:  CLRF   3F
2ED0:  MOVF   3E,W
2ED2:  SUBWF  41,W
2ED4:  BNZ   2EEC
2ED6:  MOVF   00,W
2ED8:  MOVWF  3F
2EDA:  MOVLW  2E
2EDC:  BTFSS  F9E.4
2EDE:  BRA    2EDC
2EE0:  MOVWF  FAD
2EE2:  MOVF   3F,W
2EE4:  MOVWF  00
2EE6:  MOVLW  20
2EE8:  ANDWF  3F,F
2EEA:  MOVLW  00
2EEC:  MOVLW  30
2EEE:  BTFSS  3F.5
2EF0:  BRA    2F0E
2EF2:  BCF    3F.5
2EF4:  MOVF   3E,W
2EF6:  BTFSS  FD8.2
2EF8:  DECF   3F,F
2EFA:  MOVF   00,W
2EFC:  MOVWF  3F
2EFE:  MOVLW  2D
2F00:  BTFSS  F9E.4
2F02:  BRA    2F00
2F04:  MOVWF  FAD
2F06:  MOVF   3F,W
2F08:  MOVWF  00
2F0A:  CLRF   3F
2F0C:  MOVLW  30
2F0E:  ADDWF  00,F
2F10:  MOVF   00,W
2F12:  BTFSS  F9E.4
2F14:  BRA    2F12
2F16:  MOVWF  FAD
2F18:  BCF    FD8.1
2F1A:  MOVFF  46,4A
2F1E:  MOVFF  45,49
2F22:  MOVFF  44,48
2F26:  MOVFF  43,47
2F2A:  CLRF   4E
2F2C:  CLRF   4D
2F2E:  CLRF   4C
2F30:  MOVLW  0A
2F32:  MOVWF  4B
2F34:  RCALL  2D3E
2F36:  MOVFF  03,46
2F3A:  MOVFF  02,45
2F3E:  MOVFF  01,44
2F42:  MOVFF  00,43
2F46:  DECFSZ 41,F
2F48:  BRA    2E60
2F4A:  RETURN 0
2F4C:  MOVF   FE9,W
2F4E:  MOVWF  3F
2F50:  MOVF   3E,W
2F52:  MOVWF  41
2F54:  BZ    2F88
2F56:  MOVFF  3D,4A
2F5A:  MOVFF  3C,49
2F5E:  MOVFF  3B,48
2F62:  MOVFF  3A,47
2F66:  CLRF   4E
2F68:  CLRF   4D
2F6A:  MOVLW  20
2F6C:  MOVWF  4C
2F6E:  MOVLW  82
2F70:  MOVWF  4B
2F72:  RCALL  284A
2F74:  MOVFF  03,3D
2F78:  MOVFF  02,3C
2F7C:  MOVFF  01,3B
2F80:  MOVFF  00,3A
2F84:  DECFSZ 41,F
2F86:  BRA    2F56
2F88:  MOVFF  3D,4A
2F8C:  MOVFF  3C,49
2F90:  MOVFF  3B,48
2F94:  MOVFF  3A,47
2F98:  RCALL  2D00
2F9A:  MOVFF  03,3D
2F9E:  MOVFF  02,3C
2FA2:  MOVFF  01,3B
2FA6:  MOVFF  00,3A
2FAA:  BTFSS  3D.7
2FAC:  BRA    2FC8
2FAE:  DECF   3F,F
2FB0:  BSF    3F.5
2FB2:  COMF   3A,F
2FB4:  COMF   3B,F
2FB6:  COMF   3C,F
2FB8:  COMF   3D,F
2FBA:  INCF   3A,F
2FBC:  BTFSC  FD8.2
2FBE:  INCF   3B,F
2FC0:  BTFSC  FD8.2
2FC2:  INCF   3C,F
2FC4:  BTFSC  FD8.2
2FC6:  INCF   3D,F
2FC8:  MOVLW  3B
2FCA:  MOVWF  46
2FCC:  MOVLW  9A
2FCE:  MOVWF  45
2FD0:  MOVLW  CA
2FD2:  MOVWF  44
2FD4:  CLRF   43
2FD6:  MOVLW  0A
2FD8:  MOVWF  41
2FDA:  MOVF   3E,W
2FDC:  BTFSC  FD8.2
2FDE:  INCF   3F,F
2FE0:  BSF    FD8.1
2FE2:  CLRF   FEA
2FE4:  MOVLW  3A
2FE6:  MOVWF  FE9
2FE8:  MOVFF  3D,4A
2FEC:  MOVFF  3C,49
2FF0:  MOVFF  3B,48
2FF4:  MOVFF  3A,47
2FF8:  MOVFF  46,4E
2FFC:  MOVFF  45,4D
3000:  MOVFF  44,4C
3004:  MOVFF  43,4B
3008:  RCALL  2D3E
300A:  MOVF   01,W
300C:  MOVF   00,F
300E:  BNZ   302E
3010:  INCF   3E,W
3012:  SUBWF  41,W
3014:  BZ    302E
3016:  MOVF   3F,W
3018:  BZ    3032
301A:  ANDLW  0F
301C:  SUBWF  41,W
301E:  BZ    3022
3020:  BC    30C8
3022:  BTFSC  3F.7
3024:  BRA    30C8
3026:  BTFSC  3F.6
3028:  BRA    3032
302A:  MOVLW  20
302C:  BRA    30B2
302E:  MOVLW  20
3030:  ANDWF  3F,F
3032:  BTFSS  3F.5
3034:  BRA    305C
3036:  BCF    3F.5
3038:  MOVF   3E,W
303A:  BTFSS  FD8.2
303C:  DECF   3F,F
303E:  MOVF   00,W
3040:  MOVWF  3F
3042:  CLRF   19
3044:  BTFSC  FF2.7
3046:  BSF    19.7
3048:  BCF    FF2.7
304A:  MOVLW  2D
304C:  MOVWF  5A
304E:  CALL   232E
3052:  BTFSC  19.7
3054:  BSF    FF2.7
3056:  MOVF   3F,W
3058:  MOVWF  00
305A:  CLRF   3F
305C:  MOVF   3E,W
305E:  SUBWF  41,W
3060:  BNZ   3084
3062:  MOVF   00,W
3064:  MOVWF  3F
3066:  CLRF   19
3068:  BTFSC  FF2.7
306A:  BSF    19.7
306C:  BCF    FF2.7
306E:  MOVLW  2E
3070:  MOVWF  5A
3072:  CALL   232E
3076:  BTFSC  19.7
3078:  BSF    FF2.7
307A:  MOVF   3F,W
307C:  MOVWF  00
307E:  MOVLW  20
3080:  ANDWF  3F,F
3082:  MOVLW  00
3084:  MOVLW  30
3086:  BTFSS  3F.5
3088:  BRA    30B2
308A:  BCF    3F.5
308C:  MOVF   3E,W
308E:  BTFSS  FD8.2
3090:  DECF   3F,F
3092:  MOVF   00,W
3094:  MOVWF  3F
3096:  CLRF   19
3098:  BTFSC  FF2.7
309A:  BSF    19.7
309C:  BCF    FF2.7
309E:  MOVLW  2D
30A0:  MOVWF  5A
30A2:  CALL   232E
30A6:  BTFSC  19.7
30A8:  BSF    FF2.7
30AA:  MOVF   3F,W
30AC:  MOVWF  00
30AE:  CLRF   3F
30B0:  MOVLW  30
30B2:  ADDWF  00,F
30B4:  CLRF   19
30B6:  BTFSC  FF2.7
30B8:  BSF    19.7
30BA:  BCF    FF2.7
30BC:  MOVFF  00,5A
30C0:  CALL   232E
30C4:  BTFSC  19.7
30C6:  BSF    FF2.7
30C8:  BCF    FD8.1
30CA:  MOVFF  46,4A
30CE:  MOVFF  45,49
30D2:  MOVFF  44,48
30D6:  MOVFF  43,47
30DA:  CLRF   4E
30DC:  CLRF   4D
30DE:  CLRF   4C
30E0:  MOVLW  0A
30E2:  MOVWF  4B
30E4:  RCALL  2D3E
30E6:  MOVFF  03,46
30EA:  MOVFF  02,45
30EE:  MOVFF  01,44
30F2:  MOVFF  00,43
30F6:  DECFSZ 41,F
30F8:  BRA    2FE0
30FA:  RETURN 0
30FC:  MOVFF  3B,42
3100:  MOVF   3F,W
3102:  XORWF  42,F
3104:  BTFSS  42.7
3106:  BRA    3112
3108:  BCF    FD8.2
310A:  BCF    FD8.0
310C:  BTFSC  3B.7
310E:  BSF    FD8.0
3110:  BRA    3170
3112:  MOVFF  3B,42
3116:  MOVFF  3E,43
311A:  MOVF   3A,W
311C:  SUBWF  43,F
311E:  BZ    312C
3120:  BTFSS  42.7
3122:  BRA    3170
3124:  MOVF   FD8,W
3126:  XORLW  01
3128:  MOVWF  FD8
312A:  BRA    3170
312C:  MOVFF  3F,43
3130:  MOVF   3B,W
3132:  SUBWF  43,F
3134:  BZ    3142
3136:  BTFSS  42.7
3138:  BRA    3170
313A:  MOVF   FD8,W
313C:  XORLW  01
313E:  MOVWF  FD8
3140:  BRA    3170
3142:  MOVFF  40,43
3146:  MOVF   3C,W
3148:  SUBWF  43,F
314A:  BZ    3158
314C:  BTFSS  42.7
314E:  BRA    3170
3150:  MOVF   FD8,W
3152:  XORLW  01
3154:  MOVWF  FD8
3156:  BRA    3170
3158:  MOVFF  41,43
315C:  MOVF   3D,W
315E:  SUBWF  43,F
3160:  BZ    316E
3162:  BTFSS  42.7
3164:  BRA    3170
3166:  MOVF   FD8,W
3168:  XORLW  01
316A:  MOVWF  FD8
316C:  BRA    3170
316E:  BCF    FD8.0
3170:  RETURN 0
*
40E4:  ADDWF  FE8,W
40E6:  CLRF   FF7
40E8:  RLCF   FF7,F
40EA:  ADDLW  FF
40EC:  MOVWF  FF6
40EE:  MOVLW  40
40F0:  ADDWFC FF7,F
40F2:  TBLRD*-
40F4:  MOVF   FF5,W
40F6:  MOVWF  FFA
40F8:  TBLRD*
40FA:  MOVF   FF5,W
40FC:  MOVWF  FF9
40FE:  DATA 88,40
4100:  DATA 96,40
4102:  DATA A4,40
4104:  DATA B2,40
4106:  DATA C0,40
4108:  DATA CE,40
410A:  DATA DE,40
410C:  DATA DC,40
....................  
.................... #list 
....................  
....................    #device ADC=10 
....................    #include <usb_bootloader.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                     USB_BOOTLOADER.H                              //// 
.................... ////                                                                   //// 
.................... ////  This include file must be included by any application loaded     //// 
.................... ////  by the example USB bootloader (ex_usb_bootloader                 //// 
.................... ////                                                                   //// 
.................... ////  The directives in this file relocate the reset and interrupt     //// 
.................... ////  vectors as well as reserving space for the bootloader.           //// 
.................... ////                                                                   //// 
.................... ////  For more documentation see ex_usb_bootloader.c                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// VERSION HISTORY                                                   //// 
.................... ////                                                                   //// 
.................... //// July 9th, 2012:                                                   //// 
.................... ////  Added support for PCD (see ex_usb_bootloader.c).                 //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define LOADER_START       (0) 
.................... #define LOADER_SIZE        (0x2000) 
....................  
.................... #if defined(__USB_87J50__) 
....................  #define APPLICATION_END    (getenv("PROGRAM_MEMORY")-9) //configuration bits 
.................... #elif defined(__PCD__) 
....................  #define APPLICATION_END    (getenv("PROGRAM_MEMORY")-2) 
.................... #else 
....................  #define APPLICATION_END    (getenv("PROGRAM_MEMORY")-1) 
.................... #endif 
....................  
.................... #if defined(__PCM__) 
....................    #define LOADER_END      (LOADER_SIZE+0x40-1) 
.................... #elif defined(__PCH__) 
....................    #define FLASH_SIZE getenv("FLASH_ERASE_SIZE") 
....................    #if (((LOADER_SIZE) % FLASH_SIZE) == 0 )       //IF LOADER_SIZE is even flash boundary 
....................       #define LOADER_END   (LOADER_SIZE-1) 
....................    #else                                  //ELSE, goto next even boundary 
....................       #define LOADER_END   (((LOADER_SIZE)+FLASH_SIZE-((LOADER_SIZE)%FLASH_SIZE))-1) 
....................    #endif 
.................... #elif defined(__PCD__) 
....................    #define FLASH_SIZE getenv("FLASH_ERASE_SIZE")/2 
....................    #if (((LOADER_START+LOADER_SIZE) % FLASH_SIZE) == 0) 
....................       #define LOADER_END (LOADER_START+LOADER_SIZE-1) 
....................    #else 
....................       #define LOADER_END (LOADER_START+(LOADER_SIZE+FLASH_SIZE-((LOADER_SIZE)%FLASH_SIZE))-1) 
....................    #endif 
.................... #else 
....................  #error PCM, PCH, and PCD only supported 
.................... #endif 
....................  
.................... #define APPLICATION_START  (LOADER_END+1) 
....................  
.................... #if defined(__PCH__) 
....................  #define APPLICATION_ISR (APPLICATION_START+8) 
.................... #elif defined(__PCM__) 
....................  #define APPLICATION_ISR (APPLICATION_START+4) 
.................... #elif defined(__PCD__) 
....................  #define APPLICATION_ISR (APPLICATION_START+4) 
.................... #endif 
....................  
.................... //// --- end configuration --- //////////////////////////////////////////// 
....................  
.................... #ifdef _bootloader 
....................  // bootloader won't use interrupts, instead it will poll USB IF 
....................  #define USB_ISR_POLLING 
....................   
....................  /* 
....................   Provide an empty application, so if you load this .HEX file into the pic 
....................   without an application this will prevent the pic from executing unknown code. 
....................  */ 
....................  #org APPLICATION_START,APPLICATION_START+0xF 
....................  void BlankApplication(void)  
....................  { 
....................    while(TRUE); 
....................  } 
....................  
....................  //we need to prevent the loader from using application space 
....................  #if (APPLICATION_END > 0x10000) 
....................    #org APPLICATION_START+0x10, 0xFFFF {} 
....................    #if (APPLICATION_END > 0x20000) 
....................       #org 0x10000, 0x1FFFF {} 
....................       #org 0x20000, APPLICATION_END {} 
....................    #else 
....................       #org 0x10000, APPLICATION_END {} 
....................    #endif 
....................  #else 
....................    #org APPLICATION_START+0x10, APPLICATION_END {} 
....................  #endif 
....................  
....................    #define USB_STRINGS_OVERWRITTEN 
....................    char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................     
....................    #define USB_CONFIG_PID  0x000c 
....................  
....................    // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
....................    // Strings are saved as unicode. 
....................    // These strings are mostly only displayed during the add hardware wizard. 
....................    // Once the operating system drivers have been installed it will usually display 
....................    // the name from the drivers .INF. 
....................    char const USB_STRING_DESC[]={ 
....................       //string 0 
....................             4, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             0x09,0x04,   //Microsoft Defined for US-English 
....................       //string 1  - manufacturer 
....................             8, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             'C',0, 
....................             'C',0, 
....................             'S',0, 
....................       //string 2 - product 
....................             38, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             'C',0, 
....................             'C',0, 
....................             'S',0, 
....................             ' ',0, 
....................             'C',0, 
....................             'D',0, 
....................             'C',0, 
....................             ' ',0, 
....................             'B',0, 
....................             'o',0, 
....................             'o',0, 
....................             't',0, 
....................             'l',0, 
....................             'o',0, 
....................             'a',0, 
....................             'd',0, 
....................             'e',0, 
....................             'r',0 
....................    }; 
.................... #endif   //_bootloader 
....................  
.................... #ifndef _bootloader 
....................  //in the application, this moves the reset and isr vector out of the bootload 
....................  //space.  it then reserves the loader space from being used by the application. 
....................  #build(reset=APPLICATION_START, interrupt=APPLICATION_ISR) 
....................   
....................  #org 0, LOADER_END {} 
....................  
.................... #endif 
....................  
....................    #fuses HS,NOWDT,NOPROTECT,NOLVP 
....................    #define cuenta 15536 
....................    #include <time.h> 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                       /// 
.................... ///                               time.h                                  /// 
.................... ///                                                                       /// 
.................... /// Time algorithms.  This follows the standard C API, with the following /// 
.................... /// exceptions:                                                           /// 
.................... ///   * ctime() has another input parameter which is the pointer to where /// 
.................... ///     the input string is.  Normally ctime() and asctime() write the    /// 
.................... ///     output to a globally allocated string and return a pointer to     /// 
.................... ///     this string.  This library doesn't want to make this assumption   /// 
.................... ///     so the library doesn't allocate the space needed for those        /// 
.................... ///     functions.                                                        /// 
.................... ///   * asctime() has nother input parameter which is the pointer to      /// 
.................... ///     where the input string is.  See the above paragraph.              /// 
.................... ///   * strftime() is not supported.                                      /// 
.................... ///   * SetTime() is added that initializes/set the current time.         /// 
.................... ///   * GetTime() is added so you can read directly into a struct_tm,     /// 
.................... ///      instead of having to use localtime(time()) which is usually      /// 
.................... ///       innefecient.                                                    /// 
.................... ///   * TimeInit() added for any real time clock devices that may need    /// 
.................... ///      to be initialized first.                                         /// 
.................... ///   * Not all timebases have a tick system, so it's not recommended     /// 
.................... ///      to use clock().  If you need clock(), look at CCS's              /// 
.................... ///      #use timer() library.                                            /// 
.................... ///                                                                       /// 
.................... /// This file only provides the prototypes and definitions needed to      /// 
.................... /// proved a time alogrithm that follows the C standard library.  You     /// 
.................... /// also need to include/link the actual library that performs the time   /// 
.................... /// base.  As of this writing CCS provides the following compatible       /// 
.................... /// timebase libraries:                                                   /// 
.................... ///      rtcperipheral.c - for PICs with internal real time clock.        /// 
.................... ///      ds1305.c - external DS1305 real time clock.                      /// 
.................... ///      rtcticks.c - Use a PIC's timer with CCS #use timer() library.    /// 
.................... ///                                                                       /// 
.................... /// API:                                                                  /// 
.................... ///                                                                       /// 
.................... /// Variable definitions:                                                 /// 
.................... ///   c - clock timer (clock_t), number of ticks since powerup.  See      /// 
.................... ///       CLOCKS_PER_SECOND to determine clock rate.                      /// 
.................... ///                                                                       /// 
.................... ///   t - second timer (time_t), number of seconds since Jan 1st, 1970.   /// 
.................... ///                                                                       /// 
.................... ///   ts - time struct (struct_tm), a structure that holds time in        /// 
.................... ///        descriptive format (seconds, minutes, hours, day, month, etc). /// 
.................... ///                                                                       /// 
.................... /// CLOCKS_PER_SECOND - This is a constant which needs to be defined that /// 
.................... ///   configures the timebase used by the clock timer and clock().        /// 
.................... ///   If you are not using clock() then you don't need to define this.    /// 
.................... ///   If you are using a method such a PIC's timer for the timebase then  /// 
.................... ///   you will need to set this.                                          /// 
.................... ///                                                                       /// 
.................... /// c = clock() - Return current clock timer.                             /// 
.................... ///                                                                       /// 
.................... /// t = time(*t) - Return current second timer.  Returns twice (as a      /// 
.................... ///         a return, and saves to input pointer).                        /// 
.................... ///                                                                       /// 
.................... /// SetTime(*tm) - Initializes the current time with a struct_tm          /// 
.................... ///                                                                       /// 
.................... /// SetTimeSec(t) - Initializes the current time with a seconds time      /// 
.................... ///                                                                       /// 
.................... /// t = mktime(*tm) - Converts a time struct to a second timer.           /// 
.................... ///                                                                       /// 
.................... /// t = difftime(t,t) - Returns difference between two second timers.     /// 
.................... ///                                                                       /// 
.................... /// *char = ctime(*t, *char) - Converts second timer to a readable string /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *char = asctime(*ts, *char) - Converts time struct to a readable      /// 
.................... ///                            string.                                    /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *ts = localtime(*t) - Converts second timer to a time struct.         /// 
.................... ///                  *ts points to a global time struct and will be       /// 
.................... ///                  corrupted in future calls to localtime().            /// 
.................... ///                                                                       /// 
.................... /// GetTime(*tm) - Returns the current time as a time struct              /// 
.................... ///                                                                       /// 
.................... /// TimeInit() - Initializes the timing device                            /// 
.................... ///                                                                       /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_H__ 
.................... #define __TIME_H__ 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
.................... #USE DYNAMIC_MEMORY 
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu\r\n", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
....................  
.................... /* API Types*/ 
.................... typedef signed int32 time_t; 
.................... typedef unsigned int32 clock_t; 
....................  
.................... typedef enum 
.................... { 
....................    SUNDAY = 0, 
....................    MONDAY, 
....................    TUESDAY, 
....................    WEDNESDAY, 
....................    THURSDAY, 
....................    FRIDAY, 
....................    SATURDAY    
.................... }  Weekday; 
....................  
.................... typedef enum 
.................... { 
....................    JANUARY = 0, 
....................    FEBRUARY, 
....................    MARCH, 
....................    APRIL, 
....................    MAY, 
....................    JUNE, 
....................    JULY, 
....................    AUGUST, 
....................    SEPTEMBER, 
....................    OCTOBER, 
....................    NOVEMBER, 
....................    DECEMBER 
.................... }  Month; 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8 tm_sec;   // seconds after the minute (0-59) 
....................    unsigned int8 tm_min;   // minutes after the hour (0-59) 
....................    unsigned int8 tm_hour;  // hours since midnight (0-23) 
....................    unsigned int8 tm_mday;  // day of the month (0-30) 
....................    Month tm_mon;           // month of the year (0-11) 
....................    unsigned int16 tm_year; // years since 1900 
....................    Weekday tm_wday;        // day of the week (0-6) (Sunday=0) 
....................    unsigned int16 tm_yday; // day of the year (0-365) 
.................... } struct_tm; 
....................  
....................  
.................... /* Functions */ 
.................... clock_t clock(void); 
.................... time_t time(time_t * timer); 
.................... signed int32 difftime(time_t later, time_t earlier); 
.................... time_t mktime(struct_tm * timeT); 
....................  
.................... char * asctime(struct_tm * timeptr, char *szTime); 
.................... char * ctime(time_t * timer, char *szTime); 
.................... struct_tm * localtime ( time_t * timer ); 
.................... void SetTime(struct_tm * nTime); 
.................... void SetTimeSec(time_t sTime); 
.................... void GetTime(struct_tm *pRetTm); 
.................... void TimeInit(void); 
....................  
.................... #endif 
....................  
....................    #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................    #use Delay(Clock=20M) 
*
20F2:  CLRF   FEA
20F4:  MOVLW  5B
20F6:  MOVWF  FE9
20F8:  MOVF   FEF,W
20FA:  BZ    2116
20FC:  MOVLW  06
20FE:  MOVWF  01
2100:  CLRF   00
2102:  DECFSZ 00,F
2104:  BRA    2102
2106:  DECFSZ 01,F
2108:  BRA    2100
210A:  MOVLW  7B
210C:  MOVWF  00
210E:  DECFSZ 00,F
2110:  BRA    210E
2112:  DECFSZ FEF,F
2114:  BRA    20FC
2116:  RETURN 0
....................     
....................    #use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7) 
....................    #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
221C:  MOVLW  0F
221E:  ANDWF  F95,W
2220:  IORLW  F0
2222:  MOVWF  F95
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
2224:  BSF    F8C.2
....................    delay_cycles(1); 
2226:  NOP   
....................    lcd_output_enable(1); 
2228:  BSF    F8C.0
....................    delay_cycles(1); 
222A:  NOP   
....................    high = lcd_read_nibble(); 
222C:  RCALL  2210
222E:  MOVFF  01,62
....................        
....................    lcd_output_enable(0); 
2232:  BCF    F8C.0
....................    delay_cycles(1); 
2234:  NOP   
....................    lcd_output_enable(1); 
2236:  BSF    F8C.0
....................    delay_us(1); 
2238:  BRA    223A
223A:  BRA    223C
223C:  NOP   
....................    low = lcd_read_nibble(); 
223E:  RCALL  2210
2240:  MOVFF  01,61
....................        
....................    lcd_output_enable(0); 
2244:  BCF    F8C.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
2246:  MOVLW  0F
2248:  ANDWF  F95,W
224A:  MOVWF  F95
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
224C:  SWAPF  x62,W
224E:  MOVWF  00
2250:  MOVLW  F0
2252:  ANDWF  00,F
2254:  MOVF   00,W
2256:  IORWF  x61,W
2258:  MOVWF  01
225A:  RETURN 0
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
2210:  MOVF   F83,W
2212:  MOVWF  00
2214:  SWAPF  00,W
2216:  ANDLW  0F
2218:  MOVWF  01
....................   #endif 
221A:  RETURN 0
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
21EE:  SWAPF  x62,W
21F0:  ANDLW  F0
21F2:  MOVWF  00
21F4:  MOVLW  0F
21F6:  ANDWF  F8C,W
21F8:  IORWF  00,W
21FA:  MOVWF  F8C
....................   #endif 
....................        
....................    delay_cycles(1); 
21FC:  NOP   
....................    lcd_output_enable(1); 
21FE:  BSF    F8C.0
....................    delay_us(2); 
2200:  MOVLW  02
2202:  MOVWF  00
2204:  DECFSZ 00,F
2206:  BRA    2204
2208:  BRA    220A
220A:  NOP   
....................    lcd_output_enable(0); 
220C:  BCF    F8C.0
220E:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
225C:  BCF    F95.0
....................    lcd_rs_tris(); 
225E:  BCF    F95.1
....................    lcd_rw_tris(); 
2260:  BCF    F95.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
2262:  BCF    F8C.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
2264:  RCALL  221C
2266:  MOVFF  01,61
226A:  BTFSC  01.7
226C:  BRA    2264
....................    lcd_output_rs(address); 
226E:  BCF    F8C.1
2270:  BTFSC  5F.0
2272:  BSF    F8C.1
....................    delay_cycles(1); 
2274:  NOP   
....................    lcd_output_rw(0); 
2276:  BCF    F8C.2
....................    delay_cycles(1); 
2278:  NOP   
....................    lcd_output_enable(0); 
227A:  BCF    F8C.0
....................    lcd_send_nibble(n >> 4); 
227C:  SWAPF  x60,W
227E:  MOVWF  x61
2280:  MOVLW  0F
2282:  ANDWF  x61,F
2284:  MOVFF  61,62
2288:  RCALL  21EE
....................    lcd_send_nibble(n & 0xf); 
228A:  MOVF   x60,W
228C:  ANDLW  0F
228E:  MOVWF  x61
2290:  MOVWF  x62
2292:  RCALL  21EE
2294:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
2296:  MOVLW  28
2298:  MOVWF  55
229A:  MOVLW  0C
229C:  MOVWF  56
229E:  MOVLW  01
22A0:  MOVWF  57
22A2:  MOVLW  06
22A4:  MOVWF  58
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
22A6:  BCF    F8C.0
....................    lcd_output_rs(0); 
22A8:  BCF    F8C.1
....................    lcd_output_rw(0); 
22AA:  BCF    F8C.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
22AC:  MOVLW  0F
22AE:  ANDWF  F95,W
22B0:  MOVWF  F95
....................   #endif 
....................    lcd_enable_tris(); 
22B2:  BCF    F95.0
....................    lcd_rs_tris(); 
22B4:  BCF    F95.1
....................    lcd_rw_tris(); 
22B6:  BCF    F95.2
....................  #endif 
....................      
....................    delay_ms(15); 
22B8:  MOVLW  0F
22BA:  MOVWF  5B
22BC:  RCALL  20F2
....................    for(i=1;i<=3;++i) 
22BE:  MOVLW  01
22C0:  MOVWF  54
22C2:  MOVF   54,W
22C4:  SUBLW  03
22C6:  BNC   22D8
....................    { 
....................        lcd_send_nibble(3); 
22C8:  MOVLW  03
22CA:  MOVWF  x62
22CC:  RCALL  21EE
....................        delay_ms(5); 
22CE:  MOVLW  05
22D0:  MOVWF  5B
22D2:  RCALL  20F2
22D4:  INCF   54,F
22D6:  BRA    22C2
....................    } 
....................     
....................    lcd_send_nibble(2); 
22D8:  MOVLW  02
22DA:  MOVWF  x62
22DC:  RCALL  21EE
....................    delay_ms(5); 
22DE:  MOVLW  05
22E0:  MOVWF  5B
22E2:  RCALL  20F2
....................    for(i=0;i<=3;++i) 
22E4:  CLRF   54
22E6:  MOVF   54,W
22E8:  SUBLW  03
22EA:  BNC   230A
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
22EC:  CLRF   03
22EE:  MOVF   54,W
22F0:  ADDLW  55
22F2:  MOVWF  FE9
22F4:  MOVLW  00
22F6:  ADDWFC 03,W
22F8:  MOVWF  FEA
22FA:  MOVFF  FEF,59
22FE:  CLRF   5F
2300:  MOVFF  59,60
2304:  RCALL  225C
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
2306:  INCF   54,F
2308:  BRA    22E6
230A:  RETURN 0
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
230C:  DECFSZ 5C,W
230E:  BRA    2312
2310:  BRA    2318
....................       address=LCD_LINE_TWO; 
2312:  MOVLW  40
2314:  MOVWF  5D
2316:  BRA    231A
....................    else 
....................       address=0; 
2318:  CLRF   5D
....................       
....................    address+=x-1; 
231A:  MOVLW  01
231C:  SUBWF  5B,W
231E:  ADDWF  5D,F
....................    lcd_send_byte(0,0x80|address); 
2320:  MOVF   5D,W
2322:  IORLW  80
2324:  MOVWF  5E
2326:  CLRF   5F
2328:  MOVWF  x60
232A:  RCALL  225C
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
232C:  RETURN 0
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
232E:  MOVF   5A,W
2330:  XORLW  07
2332:  BZ    2342
2334:  XORLW  0B
2336:  BZ    234C
2338:  XORLW  06
233A:  BZ    235C
233C:  XORLW  02
233E:  BZ    2368
2340:  BRA    2372
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
2342:  MOVLW  01
2344:  MOVWF  5B
2346:  MOVWF  5C
2348:  RCALL  230C
234A:  BRA    237C
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
234C:  CLRF   5F
234E:  MOVLW  01
2350:  MOVWF  x60
2352:  RCALL  225C
....................                      delay_ms(2); 
2354:  MOVLW  02
2356:  MOVWF  5B
2358:  RCALL  20F2
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
235A:  BRA    237C
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
235C:  MOVLW  01
235E:  MOVWF  5B
2360:  MOVLW  02
2362:  MOVWF  5C
2364:  RCALL  230C
2366:  BRA    237C
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
2368:  CLRF   5F
236A:  MOVLW  10
236C:  MOVWF  x60
236E:  RCALL  225C
2370:  BRA    237C
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
2372:  MOVLW  01
2374:  MOVWF  5F
2376:  MOVFF  5A,60
237A:  RCALL  225C
....................      #endif 
....................    } 
237C:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................    //------------- Declaracin de funciones ------------------- 
....................    void rota(int ciclos); 
....................    void semaforo(int ciclosdos); 
....................    void menuderotas(void); 
....................    void tempvolt(void); 
....................    void invernadero(void); 
....................    void controlmanualinv(void); 
....................    //--------------ROTAS INT RB------------------------------ 
....................    //------------------Declaracin de variables------------- 
....................    int *ptr,aux=0,contador=0,flag=0,seg=-1,min=-1,hr=-1; 
....................    char opcion='7'; 
....................    char tecla='0'; 
....................    //-----------------Interrupciones------------------------ 
....................     
....................    //-----------------Interrupcion teclado------------------ 
....................    #INT_RB        //Interrupt por el Puerto B 
....................    void intext_isr() { 
....................        
....................           OUTPUT_LOW(PIN_B2);  //Fila1 
*
2118:  BCF    F93.2
211A:  BCF    F8A.2
....................           OUTPUT_HIGH(PIN_B3);  //Fila2 
211C:  BCF    F93.3
211E:  BSF    F8A.3
....................           OUTPUT_HIGH(PIN_B4);  //fila3 
2120:  BCF    F93.4
2122:  BSF    F8A.4
....................           
....................          if(INPUT(PIN_B5)== 0){ 
2124:  BSF    F93.5
2126:  BTFSC  F81.5
2128:  BRA    212E
....................              tecla= '1'; 
212A:  MOVLW  31
212C:  MOVWF  2B
....................          } 
....................          if(INPUT(PIN_B6)== 0){ 
212E:  BSF    F93.6
2130:  BTFSC  F81.6
2132:  BRA    2138
....................              tecla= '2'; 
2134:  MOVLW  32
2136:  MOVWF  2B
....................          } 
....................          if(INPUT(PIN_B7)== 0){ 
2138:  BSF    F93.7
213A:  BTFSC  F81.7
213C:  BRA    2142
....................              tecla= '3'; 
213E:  MOVLW  33
2140:  MOVWF  2B
....................          } 
....................     
....................          OUTPUT_HIGH(PIN_B2);  //Fila1 
2142:  BCF    F93.2
2144:  BSF    F8A.2
....................          OUTPUT_LOW(PIN_B3);  //Fila2 
2146:  BCF    F93.3
2148:  BCF    F8A.3
....................          OUTPUT_HIGH(PIN_B4);  //fila3 
214A:  BCF    F93.4
214C:  BSF    F8A.4
....................          if(INPUT(PIN_B5)== 0){ 
214E:  BSF    F93.5
2150:  BTFSC  F81.5
2152:  BRA    2158
....................              tecla= '4'; 
2154:  MOVLW  34
2156:  MOVWF  2B
....................          } 
....................          if(INPUT(PIN_B6)== 0){ 
2158:  BSF    F93.6
215A:  BTFSC  F81.6
215C:  BRA    2162
....................              tecla= '5'; 
215E:  MOVLW  35
2160:  MOVWF  2B
....................          } 
....................          if(INPUT(PIN_B7)== 0){ 
2162:  BSF    F93.7
2164:  BTFSC  F81.7
2166:  BRA    216C
....................              tecla= '6'; 
2168:  MOVLW  36
216A:  MOVWF  2B
....................          } 
....................     
....................          OUTPUT_HIGH(PIN_B2);  //Fila1 
216C:  BCF    F93.2
216E:  BSF    F8A.2
....................          OUTPUT_HIGH(PIN_B3);  //Fila2 
2170:  BCF    F93.3
2172:  BSF    F8A.3
....................          OUTPUT_LOW(PIN_B4);  //fila3 
2174:  BCF    F93.4
2176:  BCF    F8A.4
....................          if(INPUT(PIN_B5)== 0){ 
2178:  BSF    F93.5
217A:  BTFSC  F81.5
217C:  BRA    2182
....................              tecla= '7'; 
217E:  MOVLW  37
2180:  MOVWF  2B
....................          } 
....................          if(INPUT(PIN_B6)== 0){ 
2182:  BSF    F93.6
2184:  BTFSC  F81.6
2186:  BRA    218C
....................              tecla= '8'; 
2188:  MOVLW  38
218A:  MOVWF  2B
....................          } 
....................          if(INPUT(PIN_B7)== 0){ 
218C:  BSF    F93.7
218E:  BTFSC  F81.7
2190:  BRA    2196
....................              tecla= '9'; 
2192:  MOVLW  39
2194:  MOVWF  2B
....................          } 
....................     
....................      printf("Tecla= %c\r\n",tecla); 
2196:  MOVLW  E2
2198:  MOVWF  FF6
219A:  MOVLW  21
219C:  MOVWF  FF7
219E:  MOVLW  07
21A0:  MOVWF  54
21A2:  RCALL  20D2
21A4:  MOVF   2B,W
21A6:  BTFSS  F9E.4
21A8:  BRA    21A6
21AA:  MOVWF  FAD
21AC:  MOVLW  0D
21AE:  BTFSS  F9E.4
21B0:  BRA    21AE
21B2:  MOVWF  FAD
21B4:  MOVLW  0A
21B6:  BTFSS  F9E.4
21B8:  BRA    21B6
21BA:  MOVWF  FAD
....................      delay_ms( 1000);   
21BC:  MOVLW  04
21BE:  MOVWF  54
21C0:  MOVLW  FA
21C2:  MOVWF  5B
21C4:  RCALL  20F2
21C6:  DECFSZ 54,F
21C8:  BRA    21C0
....................      aux= INPUT_b(); // Limpiamos la bandera RBIF 
21CA:  SETF   F93
21CC:  MOVF   F81,W
21CE:  MOVWF  24
....................       OUTPUT_LOW(PIN_B2);  //Fila1 
21D0:  BCF    F93.2
21D2:  BCF    F8A.2
....................       OUTPUT_LOW(PIN_B3);  //Fila2 
21D4:  BCF    F93.3
21D6:  BCF    F8A.3
....................       OUTPUT_LOW(PIN_B4);  //fila3 
21D8:  BCF    F93.4
21DA:  BCF    F8A.4
....................    //opcion=getch(); 
....................     
....................    } 
....................     
....................    //-----------------INTERRUPCION RELOJ-------------------- 
21DC:  BCF    FF2.0
21DE:  GOTO   2084
....................    #INT_RTCC    //INT-Timer0                                                                 
....................    void clock_isr() { 
....................      set_timer0(cuenta); 
*
246E:  MOVLW  3C
2470:  MOVWF  FD7
2472:  MOVLW  B0
2474:  MOVWF  FD6
....................      contador=contador+1;                         
2476:  MOVLW  01
2478:  ADDWF  25,F
....................      if(contador>4){  
247A:  MOVF   25,W
247C:  SUBLW  04
247E:  BC    24EE
....................            contador=0; 
2480:  CLRF   25
....................            seg++; 
2482:  INCF   27,F
....................            if(seg==60){ 
2484:  MOVF   27,W
2486:  SUBLW  3C
2488:  BNZ   24A0
....................               seg=0; 
248A:  CLRF   27
....................               min++; 
248C:  INCF   28,F
....................               if(min==60){ 
248E:  MOVF   28,W
2490:  SUBLW  3C
2492:  BNZ   24A0
....................                  min=0; 
2494:  CLRF   28
....................                  hr++; 
2496:  INCF   29,F
....................                  if(hr==24){ 
2498:  MOVF   29,W
249A:  SUBLW  18
249C:  BNZ   24A0
....................                     hr=0; 
249E:  CLRF   29
....................                  } 
....................               }            
....................       } 
....................          lcd_init(); 
24A0:  RCALL  2296
....................          //delay_ms( 500 ); 
....................          lcd_gotoxy(2,2); 
24A2:  MOVLW  02
24A4:  MOVWF  5B
24A6:  MOVWF  5C
24A8:  RCALL  230C
....................            printf(lcd_putc,"\fReloj %d :%d :%d",hr, min, seg);       
24AA:  MOVLW  F4
24AC:  MOVWF  FF6
24AE:  MOVLW  24
24B0:  MOVWF  FF7
24B2:  MOVLW  07
24B4:  MOVWF  54
24B6:  RCALL  237E
24B8:  MOVFF  29,54
24BC:  MOVLW  18
24BE:  MOVWF  55
24C0:  RCALL  23C4
24C2:  MOVLW  20
24C4:  MOVWF  5A
24C6:  RCALL  232E
24C8:  MOVLW  3A
24CA:  MOVWF  5A
24CC:  RCALL  232E
24CE:  MOVFF  28,54
24D2:  MOVLW  18
24D4:  MOVWF  55
24D6:  RCALL  23C4
24D8:  MOVLW  20
24DA:  MOVWF  5A
24DC:  RCALL  232E
24DE:  MOVLW  3A
24E0:  MOVWF  5A
24E2:  RCALL  232E
24E4:  MOVFF  27,54
24E8:  MOVLW  18
24EA:  MOVWF  55
24EC:  RCALL  23C4
....................       } 
....................    } 
....................    //---------------------AJUSTE RELOJ---------------------- 
24EE:  BCF    FF2.2
24F0:  GOTO   2084
....................    #INT_EXT 
....................    void intext_isr2() { 
....................     hr++; 
*
2506:  INCF   29,F
....................     if(hr==24){ 
2508:  MOVF   29,W
250A:  SUBLW  18
250C:  BNZ   2510
....................          hr=0; 
250E:  CLRF   29
....................       } 
....................    } 
2510:  BCF    FF2.1
2512:  GOTO   2084
....................    #INT_EXT1         
....................    void intext_isr3() { 
....................     min++; 
2516:  INCF   28,F
....................     if(min>60){ 
2518:  MOVF   28,W
251A:  SUBLW  3C
251C:  BC    2522
....................          min=0; 
251E:  CLRF   28
....................            hr++; 
2520:  INCF   29,F
....................       } 
2522:  BCF    FF0.0
2524:  GOTO   2084
....................    } 
....................    //------------------------------------------------------- 
....................    void main(void) { 
*
410E:  CLRF   FF8
4110:  BCF    FD0.7
4112:  BSF    07.7
4114:  BSF    FB8.3
4116:  MOVLW  08
4118:  MOVWF  FAF
411A:  MOVLW  02
411C:  MOVWF  FB0
411E:  MOVLW  A6
4120:  MOVWF  FAC
4122:  MOVLW  90
4124:  MOVWF  FAB
4126:  CLRF   24
4128:  CLRF   25
412A:  CLRF   26
412C:  SETF   27
412E:  SETF   28
4130:  SETF   29
4132:  MOVLW  37
4134:  MOVWF  2A
4136:  MOVLW  30
4138:  MOVWF  2B
413A:  MOVF   FC1,W
413C:  ANDLW  C0
413E:  IORLW  0F
4140:  MOVWF  FC1
4142:  MOVLW  07
4144:  MOVWF  FB4
4146:  CLRF   1B
4148:  MOVLW  64
414A:  MOVWF  1A
414C:  MOVLW  07
414E:  MOVWF  x65
4150:  MOVLW  98
4152:  MOVWF  x64
4154:  CLRF   x67
4156:  CLRF   x66
4158:  CLRF   1C
415A:  CLRF   1D
....................    //lcd_init(); 
....................    set_tris_d(0x00); 
415C:  MOVLW  00
415E:  MOVWF  F95
....................    set_tris_b(0x0F0); 
4160:  MOVLW  F0
4162:  MOVWF  F93
....................    set_tris_c(0x0F0);        
4164:  MOVWF  F94
....................    PORT_B_PULLUPS(TRUE); 
4166:  BCF    FF1.7
....................    ENABLE_INTERRUPTS(GLOBAL | INT_RB);     
4168:  MOVLW  C8
416A:  IORWF  FF2,F
....................    SETUP_TIMER_0(RTCC_INTERNAL | RTCC_DIV_16); 
416C:  MOVLW  83
416E:  MOVWF  FD5
....................    //ENABLE_INTERRUPTS(GLOBAL | INT_TIMER0 ); 
....................    SET_TIMER0(cuenta); 
4170:  MOVLW  3C
4172:  MOVWF  FD7
4174:  MOVLW  B0
4176:  MOVWF  FD6
....................    EXT_INT_EDGE(H_TO_L ); 
4178:  BCF    FF1.6
....................    ENABLE_INTERRUPTS(INT_EXT); 
417A:  BSF    FF2.4
....................    ENABLE_INTERRUPTS(INT_EXT1);       
417C:  BSF    FF0.3
....................    OUTPUT_LOW(PIN_B2);  //Fila1 
417E:  BCF    F93.2
4180:  BCF    F8A.2
....................    OUTPUT_LOW(PIN_B3);  //Fila2 
4182:  BCF    F93.3
4184:  BCF    F8A.3
....................    OUTPUT_LOW(PIN_B4);  //fila3 
4186:  BCF    F93.4
4188:  BCF    F8A.4
....................    //--------TEMP/VOLT--------------------- 
....................    setup_adc(ADC_CLOCK_DIV_8); 
418A:  MOVF   FC0,W
418C:  ANDLW  C0
418E:  IORLW  01
4190:  MOVWF  FC0
4192:  BSF    FC0.7
4194:  BSF    FC2.0
....................    setup_adc_ports(AN0_TO_AN1);  //Configura los puertosa AN0 Y AN1 COMO A/D 
4196:  MOVF   FC1,W
4198:  ANDLW  C0
419A:  IORLW  0D
419C:  MOVWF  FC1
....................    setup_adc(ADC_CLOCK_INTERNAL); 
419E:  MOVF   FC0,W
41A0:  ANDLW  C0
41A2:  IORLW  07
41A4:  MOVWF  FC0
41A6:  BSF    FC0.7
41A8:  BSF    FC2.0
41AA:  CLRF   19
41AC:  BTFSC  FF2.7
41AE:  BSF    19.7
41B0:  BCF    FF2.7
....................    delay_ms(100); 
41B2:  MOVLW  64
41B4:  MOVWF  5B
41B6:  CALL   20F2
41BA:  BTFSC  19.7
41BC:  BSF    FF2.7
....................    printf("\r\nINSTRUMENTRACION.\r"); 
41BE:  MOVLW  28
41C0:  MOVWF  FF6
41C2:  MOVLW  25
41C4:  MOVWF  FF7
41C6:  CALL   27F2
....................    printf("\r\n1-Opcion 1 (Invernadero)\r"); 
41CA:  MOVLW  3E
41CC:  MOVWF  FF6
41CE:  MOVLW  25
41D0:  MOVWF  FF7
41D2:  CALL   27F2
....................    printf("\r\n2.-Opcion 2 (Control manual invernadero)\r"); 
41D6:  MOVLW  5A
41D8:  MOVWF  FF6
41DA:  MOVLW  25
41DC:  MOVWF  FF7
41DE:  CALL   27F2
....................    printf("\r\n3.-Opcion 3 (Reloj)"); 
41E2:  MOVLW  86
41E4:  MOVWF  FF6
41E6:  MOVLW  25
41E8:  MOVWF  FF7
41EA:  CALL   27F2
....................    printf("\r\nElige la opcion que decees ");  
41EE:  MOVLW  9C
41F0:  MOVWF  FF6
41F2:  MOVLW  25
41F4:  MOVWF  FF7
41F6:  CALL   27F2
....................       while(1){     
....................          if(kbhit()!=0){ 
41FA:  MOVLW  00
41FC:  BTFSC  F9E.5
41FE:  MOVLW  01
4200:  XORLW  00
4202:  BZ    4248
....................          printf("\r\nINSTRUMENTACION\r"); 
4204:  MOVLW  BA
4206:  MOVWF  FF6
4208:  MOVLW  25
420A:  MOVWF  FF7
420C:  CALL   27F2
....................          printf("\r\n1.-Opcion 1 (Invernadero)\r"); 
4210:  MOVLW  CE
4212:  MOVWF  FF6
4214:  MOVLW  25
4216:  MOVWF  FF7
4218:  CALL   27F2
....................          printf("\r\n2.-Opcion 2 (Control manual invernadero)\r"); 
421C:  MOVLW  EC
421E:  MOVWF  FF6
4220:  MOVLW  25
4222:  MOVWF  FF7
4224:  CALL   27F2
....................          printf("\r\n3.-Opcion 3 (Reloj)"); 
4228:  MOVLW  18
422A:  MOVWF  FF6
422C:  MOVLW  26
422E:  MOVWF  FF7
4230:  CALL   27F2
....................          printf("\r\nElige la opcion que decees "); 
4234:  MOVLW  2E
4236:  MOVWF  FF6
4238:  MOVLW  26
423A:  MOVWF  FF7
423C:  CALL   27F2
....................    //      delay_ms(1000); 
....................          tecla=getch();     
4240:  BTFSS  F9E.5
4242:  BRA    4240
4244:  MOVFF  FAE,2B
....................           } 
....................           switch(tecla){ 
4248:  MOVF   2B,W
424A:  XORLW  31
424C:  BZ    4258
424E:  XORLW  03
4250:  BZ    4280
4252:  XORLW  01
4254:  BZ    42A6
4256:  BRA    42C4
....................          case'1': //--------------------------- 
....................          DISABLE_INTERRUPTS(INT_TIMER0 ); 
4258:  BCF    FF2.5
....................          ptr=&invernadero; 
425A:  MOVLW  31
425C:  MOVWF  03
425E:  MOVLW  72
4260:  MOVWF  22
4262:  MOVFF  03,23
....................          invernadero(); 
4266:  GOTO   3172
426A:  CLRF   19
426C:  BTFSC  FF2.7
426E:  BSF    19.7
4270:  BCF    FF2.7
....................          delay_ms( 200 ); 
4272:  MOVLW  C8
4274:  MOVWF  5B
4276:  CALL   20F2
427A:  BTFSC  19.7
427C:  BSF    FF2.7
....................          break; 
427E:  BRA    42C4
....................          case'2': //------------------------------ 
....................          DISABLE_INTERRUPTS(INT_TIMER0 ); 
4280:  BCF    FF2.5
....................          ptr=&controlmanualinv; 
4282:  MOVLW  3F
4284:  MOVWF  03
4286:  MOVLW  FC
4288:  MOVWF  22
428A:  MOVFF  03,23
....................          controlmanualinv(); 
428E:  BRA    3FFC
4290:  CLRF   19
4292:  BTFSC  FF2.7
4294:  BSF    19.7
4296:  BCF    FF2.7
....................          delay_ms( 200 ); 
4298:  MOVLW  C8
429A:  MOVWF  5B
429C:  CALL   20F2
42A0:  BTFSC  19.7
42A2:  BSF    FF2.7
....................          break; 
42A4:  BRA    42C4
....................          case'3': //------------------------ 
....................          //lcd_init(); 
....................          ENABLE_INTERRUPTS(INT_TIMER0 );delay_ms( 500 ); 
42A6:  BSF    FF2.5
42A8:  MOVLW  02
42AA:  MOVWF  2C
42AC:  CLRF   19
42AE:  BTFSC  FF2.7
42B0:  BSF    19.7
42B2:  BCF    FF2.7
42B4:  MOVLW  FA
42B6:  MOVWF  5B
42B8:  CALL   20F2
42BC:  BTFSC  19.7
42BE:  BSF    FF2.7
42C0:  DECFSZ 2C,F
42C2:  BRA    42AC
....................          break; 
....................          } 
42C4:  BRA    41FA
....................       } 
....................    } 
....................    //----------------------Invernadero automatico------------------- 
42C6:  SLEEP 
....................    void invernadero(){ 
*
3172:  CLRF   19
3174:  BTFSC  FF2.7
3176:  BSF    19.7
3178:  BCF    FF2.7
....................    long int longdato; 
....................    float x; //Valor de temperatura 
....................    float y; //Valor de humedad 
....................    float valor; 
....................    delay_ms(100); 
317A:  MOVLW  64
317C:  MOVWF  5B
317E:  CALL   20F2
3182:  BTFSC  19.7
3184:  BSF    FF2.7
3186:  CLRF   19
3188:  BTFSC  FF2.7
318A:  BSF    19.7
318C:  BCF    FF2.7
....................    lcd_init(); 
318E:  CALL   2296
3192:  BTFSC  19.7
3194:  BSF    FF2.7
....................           output_low(PIN_A3); //VENTILADOR 
3196:  BCF    F92.3
3198:  BCF    F89.3
....................          output_low(PIN_A4); //CALEFACTOR 
319A:  BCF    F92.4
319C:  BCF    F89.4
....................             output_low(PIN_A5); //BOMBA 
319E:  BCF    F92.5
31A0:  BCF    F89.5
....................          //delay_ms(500); 
....................           set_adc_channel(0); 
31A2:  MOVLW  00
31A4:  MOVWF  01
31A6:  MOVF   FC2,W
31A8:  ANDLW  C3
31AA:  IORWF  01,W
31AC:  MOVWF  FC2
31AE:  CLRF   19
31B0:  BTFSC  FF2.7
31B2:  BSF    19.7
31B4:  BCF    FF2.7
....................          delay_ms(10);              
31B6:  MOVLW  0A
31B8:  MOVWF  5B
31BA:  CALL   20F2
31BE:  BTFSC  19.7
31C0:  BSF    FF2.7
....................           longdato= read_adc(); 
31C2:  BSF    FC2.1
31C4:  BTFSC  FC2.1
31C6:  BRA    31C4
31C8:  MOVFF  FC3,2C
31CC:  MOVFF  FC4,2D
....................          delay_us(20);        
31D0:  MOVLW  20
31D2:  MOVWF  00
31D4:  DECFSZ 00,F
31D6:  BRA    31D4
31D8:  BRA    31DA
31DA:  NOP   
....................           x= ((((float)longdato*5.0)/1023))*100-4; 
31DC:  MOVFF  2D,3B
31E0:  MOVFF  2C,3A
31E4:  CALL   2814
31E8:  MOVFF  03,3D
31EC:  MOVFF  02,3C
31F0:  MOVFF  01,3B
31F4:  MOVFF  00,3A
31F8:  MOVFF  03,4A
31FC:  MOVFF  02,49
3200:  MOVFF  01,48
3204:  MOVFF  00,47
3208:  CLRF   4E
320A:  CLRF   4D
320C:  MOVLW  20
320E:  MOVWF  4C
3210:  MOVLW  81
3212:  MOVWF  4B
3214:  CALL   284A
3218:  MOVFF  03,3D
321C:  MOVFF  02,3C
3220:  MOVFF  01,3B
3224:  MOVFF  00,3A
3228:  MOVFF  03,41
322C:  MOVFF  02,40
3230:  MOVFF  01,3F
3234:  MOVFF  00,3E
3238:  CLRF   45
323A:  MOVLW  C0
323C:  MOVWF  44
323E:  MOVLW  7F
3240:  MOVWF  43
3242:  MOVLW  88
3244:  MOVWF  42
3246:  CALL   293C
324A:  MOVFF  03,3D
324E:  MOVFF  02,3C
3252:  MOVFF  01,3B
3256:  MOVFF  00,3A
325A:  MOVFF  03,4A
325E:  MOVFF  02,49
3262:  MOVFF  01,48
3266:  MOVFF  00,47
326A:  CLRF   4E
326C:  CLRF   4D
326E:  MOVLW  48
3270:  MOVWF  4C
3272:  MOVLW  85
3274:  MOVWF  4B
3276:  CALL   284A
327A:  MOVFF  03,3D
327E:  MOVFF  02,3C
3282:  MOVFF  01,3B
3286:  MOVFF  00,3A
328A:  BSF    FD8.1
328C:  MOVFF  03,41
3290:  MOVFF  02,40
3294:  MOVFF  01,3F
3298:  MOVFF  00,3E
329C:  CLRF   45
329E:  CLRF   44
32A0:  CLRF   43
32A2:  MOVLW  81
32A4:  MOVWF  42
32A6:  CALL   2A96
32AA:  MOVFF  03,31
32AE:  MOVFF  02,30
32B2:  MOVFF  01,2F
32B6:  MOVFF  00,2E
....................           //x=x-2; 
....................          //delay_ms(200); 
....................          printf("Grados= %.1f\r",x); 
32BA:  MOVLW  4C
32BC:  MOVWF  FF6
32BE:  MOVLW  26
32C0:  MOVWF  FF7
32C2:  CLRF   19
32C4:  BTFSC  FF2.7
32C6:  BSF    19.7
32C8:  BCF    FF2.7
32CA:  MOVLW  08
32CC:  MOVWF  54
32CE:  CALL   20D2
32D2:  BTFSC  19.7
32D4:  BSF    FF2.7
32D6:  MOVLW  89
32D8:  MOVWF  FE9
32DA:  MOVFF  31,3D
32DE:  MOVFF  30,3C
32E2:  MOVFF  2F,3B
32E6:  MOVFF  2E,3A
32EA:  MOVLW  01
32EC:  MOVWF  3E
32EE:  RCALL  2DCC
32F0:  MOVLW  0D
32F2:  BTFSS  F9E.4
32F4:  BRA    32F2
32F6:  MOVWF  FAD
32F8:  CLRF   19
32FA:  BTFSC  FF2.7
32FC:  BSF    19.7
32FE:  BCF    FF2.7
....................           lcd_gotoxy(1,1); 
3300:  MOVLW  01
3302:  MOVWF  5B
3304:  MOVWF  5C
3306:  CALL   230C
330A:  BTFSC  19.7
330C:  BSF    FF2.7
....................          printf(lcd_putc,"Grados= %.1f\r",x); 
330E:  MOVLW  5A
3310:  MOVWF  FF6
3312:  MOVLW  26
3314:  MOVWF  FF7
3316:  CLRF   19
3318:  BTFSC  FF2.7
331A:  BSF    19.7
331C:  BCF    FF2.7
331E:  MOVLW  08
3320:  MOVWF  54
3322:  CALL   237E
3326:  BTFSC  19.7
3328:  BSF    FF2.7
332A:  MOVLW  89
332C:  MOVWF  FE9
332E:  MOVFF  31,3D
3332:  MOVFF  30,3C
3336:  MOVFF  2F,3B
333A:  MOVFF  2E,3A
333E:  MOVLW  01
3340:  MOVWF  3E
3342:  RCALL  2F4C
3344:  CLRF   19
3346:  BTFSC  FF2.7
3348:  BSF    19.7
334A:  BCF    FF2.7
334C:  MOVLW  0D
334E:  MOVWF  5A
3350:  CALL   232E
3354:  BTFSC  19.7
3356:  BSF    FF2.7
....................          set_adc_channel(1); 
3358:  MOVLW  04
335A:  MOVWF  01
335C:  MOVF   FC2,W
335E:  ANDLW  C3
3360:  IORWF  01,W
3362:  MOVWF  FC2
3364:  CLRF   19
3366:  BTFSC  FF2.7
3368:  BSF    19.7
336A:  BCF    FF2.7
....................          delay_ms(10); 
336C:  MOVLW  0A
336E:  MOVWF  5B
3370:  CALL   20F2
3374:  BTFSC  19.7
3376:  BSF    FF2.7
....................          valor=read_adc(); 
3378:  BSF    FC2.1
337A:  BTFSC  FC2.1
337C:  BRA    337A
337E:  MOVFF  FC4,03
3382:  MOVFF  FC3,3A
3386:  MOVFF  FC4,3B
338A:  CALL   2814
338E:  MOVFF  03,39
3392:  MOVFF  02,38
3396:  MOVFF  01,37
339A:  MOVFF  00,36
....................          delay_us(20); 
339E:  MOVLW  20
33A0:  MOVWF  00
33A2:  DECFSZ 00,F
33A4:  BRA    33A2
33A6:  BRA    33A8
33A8:  NOP   
....................          y=read_adc(); 
33AA:  BSF    FC2.1
33AC:  BTFSC  FC2.1
33AE:  BRA    33AC
33B0:  MOVFF  FC4,03
33B4:  MOVFF  FC3,3A
33B8:  MOVFF  FC4,3B
33BC:  CALL   2814
33C0:  MOVFF  03,35
33C4:  MOVFF  02,34
33C8:  MOVFF  01,33
33CC:  MOVFF  00,32
....................           delay_us(20); 
33D0:  MOVLW  20
33D2:  MOVWF  00
33D4:  DECFSZ 00,F
33D6:  BRA    33D4
33D8:  BRA    33DA
33DA:  NOP   
....................          y=(-0.17*valor)+171.4; 
33DC:  MOVLW  7B
33DE:  MOVWF  4A
33E0:  MOVLW  14
33E2:  MOVWF  49
33E4:  MOVLW  AE
33E6:  MOVWF  48
33E8:  MOVLW  7C
33EA:  MOVWF  47
33EC:  MOVFF  39,4E
33F0:  MOVFF  38,4D
33F4:  MOVFF  37,4C
33F8:  MOVFF  36,4B
33FC:  CALL   284A
3400:  MOVFF  03,3D
3404:  MOVFF  02,3C
3408:  MOVFF  01,3B
340C:  MOVFF  00,3A
3410:  BCF    FD8.1
3412:  MOVFF  03,41
3416:  MOVFF  02,40
341A:  MOVFF  01,3F
341E:  MOVFF  00,3E
3422:  MOVLW  66
3424:  MOVWF  45
3426:  MOVWF  44
3428:  MOVLW  2B
342A:  MOVWF  43
342C:  MOVLW  86
342E:  MOVWF  42
3430:  CALL   2A96
3434:  MOVFF  03,35
3438:  MOVFF  02,34
343C:  MOVFF  01,33
3440:  MOVFF  00,32
....................          y=y-15; 
3444:  BSF    FD8.1
3446:  MOVFF  35,41
344A:  MOVFF  34,40
344E:  MOVFF  33,3F
3452:  MOVFF  32,3E
3456:  CLRF   45
3458:  CLRF   44
345A:  MOVLW  70
345C:  MOVWF  43
345E:  MOVLW  82
3460:  MOVWF  42
3462:  CALL   2A96
3466:  MOVFF  03,35
346A:  MOVFF  02,34
346E:  MOVFF  01,33
3472:  MOVFF  00,32
3476:  CLRF   19
3478:  BTFSC  FF2.7
347A:  BSF    19.7
347C:  BCF    FF2.7
....................          lcd_gotoxy(1,2); 
347E:  MOVLW  01
3480:  MOVWF  5B
3482:  MOVLW  02
3484:  MOVWF  5C
3486:  CALL   230C
348A:  BTFSC  19.7
348C:  BSF    FF2.7
....................          printf("Humedad= %.1f\r",y); 
348E:  MOVLW  68
3490:  MOVWF  FF6
3492:  MOVLW  26
3494:  MOVWF  FF7
3496:  CLRF   19
3498:  BTFSC  FF2.7
349A:  BSF    19.7
349C:  BCF    FF2.7
349E:  MOVLW  09
34A0:  MOVWF  54
34A2:  CALL   20D2
34A6:  BTFSC  19.7
34A8:  BSF    FF2.7
34AA:  MOVLW  89
34AC:  MOVWF  FE9
34AE:  MOVFF  35,3D
34B2:  MOVFF  34,3C
34B6:  MOVFF  33,3B
34BA:  MOVFF  32,3A
34BE:  MOVLW  01
34C0:  MOVWF  3E
34C2:  RCALL  2DCC
34C4:  MOVLW  0D
34C6:  BTFSS  F9E.4
34C8:  BRA    34C6
34CA:  MOVWF  FAD
....................          printf(lcd_putc,"Humedad= %.1f\r",y); 
34CC:  MOVLW  78
34CE:  MOVWF  FF6
34D0:  MOVLW  26
34D2:  MOVWF  FF7
34D4:  CLRF   19
34D6:  BTFSC  FF2.7
34D8:  BSF    19.7
34DA:  BCF    FF2.7
34DC:  MOVLW  09
34DE:  MOVWF  54
34E0:  CALL   237E
34E4:  BTFSC  19.7
34E6:  BSF    FF2.7
34E8:  MOVLW  89
34EA:  MOVWF  FE9
34EC:  MOVFF  35,3D
34F0:  MOVFF  34,3C
34F4:  MOVFF  33,3B
34F8:  MOVFF  32,3A
34FC:  MOVLW  01
34FE:  MOVWF  3E
3500:  RCALL  2F4C
3502:  CLRF   19
3504:  BTFSC  FF2.7
3506:  BSF    19.7
3508:  BCF    FF2.7
350A:  MOVLW  0D
350C:  MOVWF  5A
350E:  CALL   232E
3512:  BTFSC  19.7
3514:  BSF    FF2.7
....................          delay_ms(500); 
3516:  MOVLW  02
3518:  MOVWF  3A
351A:  CLRF   19
351C:  BTFSC  FF2.7
351E:  BSF    19.7
3520:  BCF    FF2.7
3522:  MOVLW  FA
3524:  MOVWF  5B
3526:  CALL   20F2
352A:  BTFSC  19.7
352C:  BSF    FF2.7
352E:  DECFSZ 3A,F
3530:  BRA    351A
....................           while(y<50){ 
3532:  MOVFF  35,3D
3536:  MOVFF  34,3C
353A:  MOVFF  33,3B
353E:  MOVFF  32,3A
3542:  CLRF   41
3544:  CLRF   40
3546:  MOVLW  48
3548:  MOVWF  3F
354A:  MOVLW  84
354C:  MOVWF  3E
354E:  RCALL  30FC
3550:  BTFSS  FD8.0
3552:  BRA    38C8
....................          output_high(PIN_A5);//BOMBA 
3554:  BCF    F92.5
3556:  BSF    F89.5
....................           output_low(PIN_A3);//VENTILADOR  
3558:  BCF    F92.3
355A:  BCF    F89.3
....................           output_low(PIN_A4);//CALEFACCION 
355C:  BCF    F92.4
355E:  BCF    F89.4
....................          //output_low(PIN_C2);//BOMBA 
....................           set_adc_channel(0); 
3560:  MOVLW  00
3562:  MOVWF  01
3564:  MOVF   FC2,W
3566:  ANDLW  C3
3568:  IORWF  01,W
356A:  MOVWF  FC2
356C:  CLRF   19
356E:  BTFSC  FF2.7
3570:  BSF    19.7
3572:  BCF    FF2.7
....................          delay_ms(10);              
3574:  MOVLW  0A
3576:  MOVWF  5B
3578:  CALL   20F2
357C:  BTFSC  19.7
357E:  BSF    FF2.7
....................           longdato= read_adc(); 
3580:  BSF    FC2.1
3582:  BTFSC  FC2.1
3584:  BRA    3582
3586:  MOVFF  FC3,2C
358A:  MOVFF  FC4,2D
....................          delay_us(20);        
358E:  MOVLW  20
3590:  MOVWF  00
3592:  DECFSZ 00,F
3594:  BRA    3592
3596:  BRA    3598
3598:  NOP   
....................           x= ((((float)longdato*5.0)/1023))*100;   
359A:  MOVFF  2D,3B
359E:  MOVFF  2C,3A
35A2:  CALL   2814
35A6:  MOVFF  03,3D
35AA:  MOVFF  02,3C
35AE:  MOVFF  01,3B
35B2:  MOVFF  00,3A
35B6:  MOVFF  03,4A
35BA:  MOVFF  02,49
35BE:  MOVFF  01,48
35C2:  MOVFF  00,47
35C6:  CLRF   4E
35C8:  CLRF   4D
35CA:  MOVLW  20
35CC:  MOVWF  4C
35CE:  MOVLW  81
35D0:  MOVWF  4B
35D2:  CALL   284A
35D6:  MOVFF  03,3D
35DA:  MOVFF  02,3C
35DE:  MOVFF  01,3B
35E2:  MOVFF  00,3A
35E6:  MOVFF  03,41
35EA:  MOVFF  02,40
35EE:  MOVFF  01,3F
35F2:  MOVFF  00,3E
35F6:  CLRF   45
35F8:  MOVLW  C0
35FA:  MOVWF  44
35FC:  MOVLW  7F
35FE:  MOVWF  43
3600:  MOVLW  88
3602:  MOVWF  42
3604:  CALL   293C
3608:  MOVFF  03,3D
360C:  MOVFF  02,3C
3610:  MOVFF  01,3B
3614:  MOVFF  00,3A
3618:  MOVFF  03,4A
361C:  MOVFF  02,49
3620:  MOVFF  01,48
3624:  MOVFF  00,47
3628:  CLRF   4E
362A:  CLRF   4D
362C:  MOVLW  48
362E:  MOVWF  4C
3630:  MOVLW  85
3632:  MOVWF  4B
3634:  CALL   284A
3638:  MOVFF  03,31
363C:  MOVFF  02,30
3640:  MOVFF  01,2F
3644:  MOVFF  00,2E
....................          //delay_ms(200); 
....................          printf("Grados= %.1f\r",x); 
3648:  MOVLW  88
364A:  MOVWF  FF6
364C:  MOVLW  26
364E:  MOVWF  FF7
3650:  CLRF   19
3652:  BTFSC  FF2.7
3654:  BSF    19.7
3656:  BCF    FF2.7
3658:  MOVLW  08
365A:  MOVWF  54
365C:  CALL   20D2
3660:  BTFSC  19.7
3662:  BSF    FF2.7
3664:  MOVLW  89
3666:  MOVWF  FE9
3668:  MOVFF  31,3D
366C:  MOVFF  30,3C
3670:  MOVFF  2F,3B
3674:  MOVFF  2E,3A
3678:  MOVLW  01
367A:  MOVWF  3E
367C:  CALL   2DCC
3680:  MOVLW  0D
3682:  BTFSS  F9E.4
3684:  BRA    3682
3686:  MOVWF  FAD
3688:  CLRF   19
368A:  BTFSC  FF2.7
368C:  BSF    19.7
368E:  BCF    FF2.7
....................           lcd_gotoxy(1,1); 
3690:  MOVLW  01
3692:  MOVWF  5B
3694:  MOVWF  5C
3696:  CALL   230C
369A:  BTFSC  19.7
369C:  BSF    FF2.7
....................          printf(lcd_putc,"Grados= %.1f\r",x); 
369E:  MOVLW  96
36A0:  MOVWF  FF6
36A2:  MOVLW  26
36A4:  MOVWF  FF7
36A6:  CLRF   19
36A8:  BTFSC  FF2.7
36AA:  BSF    19.7
36AC:  BCF    FF2.7
36AE:  MOVLW  08
36B0:  MOVWF  54
36B2:  CALL   237E
36B6:  BTFSC  19.7
36B8:  BSF    FF2.7
36BA:  MOVLW  89
36BC:  MOVWF  FE9
36BE:  MOVFF  31,3D
36C2:  MOVFF  30,3C
36C6:  MOVFF  2F,3B
36CA:  MOVFF  2E,3A
36CE:  MOVLW  01
36D0:  MOVWF  3E
36D2:  RCALL  2F4C
36D4:  CLRF   19
36D6:  BTFSC  FF2.7
36D8:  BSF    19.7
36DA:  BCF    FF2.7
36DC:  MOVLW  0D
36DE:  MOVWF  5A
36E0:  CALL   232E
36E4:  BTFSC  19.7
36E6:  BSF    FF2.7
....................          set_adc_channel(1); 
36E8:  MOVLW  04
36EA:  MOVWF  01
36EC:  MOVF   FC2,W
36EE:  ANDLW  C3
36F0:  IORWF  01,W
36F2:  MOVWF  FC2
36F4:  CLRF   19
36F6:  BTFSC  FF2.7
36F8:  BSF    19.7
36FA:  BCF    FF2.7
....................          delay_ms(10); 
36FC:  MOVLW  0A
36FE:  MOVWF  5B
3700:  CALL   20F2
3704:  BTFSC  19.7
3706:  BSF    FF2.7
....................          valor=read_adc(); 
3708:  BSF    FC2.1
370A:  BTFSC  FC2.1
370C:  BRA    370A
370E:  MOVFF  FC4,03
3712:  MOVFF  FC3,3A
3716:  MOVFF  FC4,3B
371A:  CALL   2814
371E:  MOVFF  03,39
3722:  MOVFF  02,38
3726:  MOVFF  01,37
372A:  MOVFF  00,36
....................          delay_us(20); 
372E:  MOVLW  20
3730:  MOVWF  00
3732:  DECFSZ 00,F
3734:  BRA    3732
3736:  BRA    3738
3738:  NOP   
....................          y=read_adc(); 
373A:  BSF    FC2.1
373C:  BTFSC  FC2.1
373E:  BRA    373C
3740:  MOVFF  FC4,03
3744:  MOVFF  FC3,3A
3748:  MOVFF  FC4,3B
374C:  CALL   2814
3750:  MOVFF  03,35
3754:  MOVFF  02,34
3758:  MOVFF  01,33
375C:  MOVFF  00,32
....................           delay_us(20); 
3760:  MOVLW  20
3762:  MOVWF  00
3764:  DECFSZ 00,F
3766:  BRA    3764
3768:  BRA    376A
376A:  NOP   
....................          y=(-0.17*valor)+171.4; 
376C:  MOVLW  7B
376E:  MOVWF  4A
3770:  MOVLW  14
3772:  MOVWF  49
3774:  MOVLW  AE
3776:  MOVWF  48
3778:  MOVLW  7C
377A:  MOVWF  47
377C:  MOVFF  39,4E
3780:  MOVFF  38,4D
3784:  MOVFF  37,4C
3788:  MOVFF  36,4B
378C:  CALL   284A
3790:  MOVFF  03,3D
3794:  MOVFF  02,3C
3798:  MOVFF  01,3B
379C:  MOVFF  00,3A
37A0:  BCF    FD8.1
37A2:  MOVFF  03,41
37A6:  MOVFF  02,40
37AA:  MOVFF  01,3F
37AE:  MOVFF  00,3E
37B2:  MOVLW  66
37B4:  MOVWF  45
37B6:  MOVWF  44
37B8:  MOVLW  2B
37BA:  MOVWF  43
37BC:  MOVLW  86
37BE:  MOVWF  42
37C0:  CALL   2A96
37C4:  MOVFF  03,35
37C8:  MOVFF  02,34
37CC:  MOVFF  01,33
37D0:  MOVFF  00,32
....................          y=y-15; 
37D4:  BSF    FD8.1
37D6:  MOVFF  35,41
37DA:  MOVFF  34,40
37DE:  MOVFF  33,3F
37E2:  MOVFF  32,3E
37E6:  CLRF   45
37E8:  CLRF   44
37EA:  MOVLW  70
37EC:  MOVWF  43
37EE:  MOVLW  82
37F0:  MOVWF  42
37F2:  CALL   2A96
37F6:  MOVFF  03,35
37FA:  MOVFF  02,34
37FE:  MOVFF  01,33
3802:  MOVFF  00,32
3806:  CLRF   19
3808:  BTFSC  FF2.7
380A:  BSF    19.7
380C:  BCF    FF2.7
....................          lcd_gotoxy(1,2); 
380E:  MOVLW  01
3810:  MOVWF  5B
3812:  MOVLW  02
3814:  MOVWF  5C
3816:  CALL   230C
381A:  BTFSC  19.7
381C:  BSF    FF2.7
....................          printf("Humedad= %.1f\r",y); 
381E:  MOVLW  A4
3820:  MOVWF  FF6
3822:  MOVLW  26
3824:  MOVWF  FF7
3826:  CLRF   19
3828:  BTFSC  FF2.7
382A:  BSF    19.7
382C:  BCF    FF2.7
382E:  MOVLW  09
3830:  MOVWF  54
3832:  CALL   20D2
3836:  BTFSC  19.7
3838:  BSF    FF2.7
383A:  MOVLW  89
383C:  MOVWF  FE9
383E:  MOVFF  35,3D
3842:  MOVFF  34,3C
3846:  MOVFF  33,3B
384A:  MOVFF  32,3A
384E:  MOVLW  01
3850:  MOVWF  3E
3852:  CALL   2DCC
3856:  MOVLW  0D
3858:  BTFSS  F9E.4
385A:  BRA    3858
385C:  MOVWF  FAD
....................          printf(lcd_putc,"Humedad= %.1f\r",y); 
385E:  MOVLW  B4
3860:  MOVWF  FF6
3862:  MOVLW  26
3864:  MOVWF  FF7
3866:  CLRF   19
3868:  BTFSC  FF2.7
386A:  BSF    19.7
386C:  BCF    FF2.7
386E:  MOVLW  09
3870:  MOVWF  54
3872:  CALL   237E
3876:  BTFSC  19.7
3878:  BSF    FF2.7
387A:  MOVLW  89
387C:  MOVWF  FE9
387E:  MOVFF  35,3D
3882:  MOVFF  34,3C
3886:  MOVFF  33,3B
388A:  MOVFF  32,3A
388E:  MOVLW  01
3890:  MOVWF  3E
3892:  CALL   2F4C
3896:  CLRF   19
3898:  BTFSC  FF2.7
389A:  BSF    19.7
389C:  BCF    FF2.7
389E:  MOVLW  0D
38A0:  MOVWF  5A
38A2:  CALL   232E
38A6:  BTFSC  19.7
38A8:  BSF    FF2.7
....................          delay_ms(500);    
38AA:  MOVLW  02
38AC:  MOVWF  3A
38AE:  CLRF   19
38B0:  BTFSC  FF2.7
38B2:  BSF    19.7
38B4:  BCF    FF2.7
38B6:  MOVLW  FA
38B8:  MOVWF  5B
38BA:  CALL   20F2
38BE:  BTFSC  19.7
38C0:  BSF    FF2.7
38C2:  DECFSZ 3A,F
38C4:  BRA    38AE
38C6:  BRA    3532
....................          } 
....................          while(x>26){ 
38C8:  CLRF   3D
38CA:  CLRF   3C
38CC:  MOVLW  50
38CE:  MOVWF  3B
38D0:  MOVLW  83
38D2:  MOVWF  3A
38D4:  MOVFF  31,41
38D8:  MOVFF  30,40
38DC:  MOVFF  2F,3F
38E0:  MOVFF  2E,3E
38E4:  RCALL  30FC
38E6:  BTFSS  FD8.0
38E8:  BRA    3C60
....................          output_high(PIN_A3);//VENTILADOR  
38EA:  BCF    F92.3
38EC:  BSF    F89.3
....................           output_low(PIN_A4);//CALEFACCION 
38EE:  BCF    F92.4
38F0:  BCF    F89.4
....................          output_low(PIN_A5);//BOMBA 
38F2:  BCF    F92.5
38F4:  BCF    F89.5
....................           set_adc_channel(0); 
38F6:  MOVLW  00
38F8:  MOVWF  01
38FA:  MOVF   FC2,W
38FC:  ANDLW  C3
38FE:  IORWF  01,W
3900:  MOVWF  FC2
3902:  CLRF   19
3904:  BTFSC  FF2.7
3906:  BSF    19.7
3908:  BCF    FF2.7
....................          delay_ms(10);              
390A:  MOVLW  0A
390C:  MOVWF  5B
390E:  CALL   20F2
3912:  BTFSC  19.7
3914:  BSF    FF2.7
....................           longdato= read_adc(); 
3916:  BSF    FC2.1
3918:  BTFSC  FC2.1
391A:  BRA    3918
391C:  MOVFF  FC3,2C
3920:  MOVFF  FC4,2D
....................          delay_us(20);        
3924:  MOVLW  20
3926:  MOVWF  00
3928:  DECFSZ 00,F
392A:  BRA    3928
392C:  BRA    392E
392E:  NOP   
....................           x= ((((float)longdato*5.0)/1023))*100;   
3930:  MOVFF  2D,3B
3934:  MOVFF  2C,3A
3938:  CALL   2814
393C:  MOVFF  03,3D
3940:  MOVFF  02,3C
3944:  MOVFF  01,3B
3948:  MOVFF  00,3A
394C:  MOVFF  03,4A
3950:  MOVFF  02,49
3954:  MOVFF  01,48
3958:  MOVFF  00,47
395C:  CLRF   4E
395E:  CLRF   4D
3960:  MOVLW  20
3962:  MOVWF  4C
3964:  MOVLW  81
3966:  MOVWF  4B
3968:  CALL   284A
396C:  MOVFF  03,3D
3970:  MOVFF  02,3C
3974:  MOVFF  01,3B
3978:  MOVFF  00,3A
397C:  MOVFF  03,41
3980:  MOVFF  02,40
3984:  MOVFF  01,3F
3988:  MOVFF  00,3E
398C:  CLRF   45
398E:  MOVLW  C0
3990:  MOVWF  44
3992:  MOVLW  7F
3994:  MOVWF  43
3996:  MOVLW  88
3998:  MOVWF  42
399A:  CALL   293C
399E:  MOVFF  03,3D
39A2:  MOVFF  02,3C
39A6:  MOVFF  01,3B
39AA:  MOVFF  00,3A
39AE:  MOVFF  03,4A
39B2:  MOVFF  02,49
39B6:  MOVFF  01,48
39BA:  MOVFF  00,47
39BE:  CLRF   4E
39C0:  CLRF   4D
39C2:  MOVLW  48
39C4:  MOVWF  4C
39C6:  MOVLW  85
39C8:  MOVWF  4B
39CA:  CALL   284A
39CE:  MOVFF  03,31
39D2:  MOVFF  02,30
39D6:  MOVFF  01,2F
39DA:  MOVFF  00,2E
....................          //delay_ms(200); 
....................          printf("Grados= %.1f\r",x); 
39DE:  MOVLW  C4
39E0:  MOVWF  FF6
39E2:  MOVLW  26
39E4:  MOVWF  FF7
39E6:  CLRF   19
39E8:  BTFSC  FF2.7
39EA:  BSF    19.7
39EC:  BCF    FF2.7
39EE:  MOVLW  08
39F0:  MOVWF  54
39F2:  CALL   20D2
39F6:  BTFSC  19.7
39F8:  BSF    FF2.7
39FA:  MOVLW  89
39FC:  MOVWF  FE9
39FE:  MOVFF  31,3D
3A02:  MOVFF  30,3C
3A06:  MOVFF  2F,3B
3A0A:  MOVFF  2E,3A
3A0E:  MOVLW  01
3A10:  MOVWF  3E
3A12:  CALL   2DCC
3A16:  MOVLW  0D
3A18:  BTFSS  F9E.4
3A1A:  BRA    3A18
3A1C:  MOVWF  FAD
3A1E:  CLRF   19
3A20:  BTFSC  FF2.7
3A22:  BSF    19.7
3A24:  BCF    FF2.7
....................           lcd_gotoxy(1,1); 
3A26:  MOVLW  01
3A28:  MOVWF  5B
3A2A:  MOVWF  5C
3A2C:  CALL   230C
3A30:  BTFSC  19.7
3A32:  BSF    FF2.7
....................          printf(lcd_putc,"Grados= %.1f\r",x); 
3A34:  MOVLW  D2
3A36:  MOVWF  FF6
3A38:  MOVLW  26
3A3A:  MOVWF  FF7
3A3C:  CLRF   19
3A3E:  BTFSC  FF2.7
3A40:  BSF    19.7
3A42:  BCF    FF2.7
3A44:  MOVLW  08
3A46:  MOVWF  54
3A48:  CALL   237E
3A4C:  BTFSC  19.7
3A4E:  BSF    FF2.7
3A50:  MOVLW  89
3A52:  MOVWF  FE9
3A54:  MOVFF  31,3D
3A58:  MOVFF  30,3C
3A5C:  MOVFF  2F,3B
3A60:  MOVFF  2E,3A
3A64:  MOVLW  01
3A66:  MOVWF  3E
3A68:  CALL   2F4C
3A6C:  CLRF   19
3A6E:  BTFSC  FF2.7
3A70:  BSF    19.7
3A72:  BCF    FF2.7
3A74:  MOVLW  0D
3A76:  MOVWF  5A
3A78:  CALL   232E
3A7C:  BTFSC  19.7
3A7E:  BSF    FF2.7
....................          set_adc_channel(1); 
3A80:  MOVLW  04
3A82:  MOVWF  01
3A84:  MOVF   FC2,W
3A86:  ANDLW  C3
3A88:  IORWF  01,W
3A8A:  MOVWF  FC2
3A8C:  CLRF   19
3A8E:  BTFSC  FF2.7
3A90:  BSF    19.7
3A92:  BCF    FF2.7
....................          delay_ms(10); 
3A94:  MOVLW  0A
3A96:  MOVWF  5B
3A98:  CALL   20F2
3A9C:  BTFSC  19.7
3A9E:  BSF    FF2.7
....................          valor=read_adc(); 
3AA0:  BSF    FC2.1
3AA2:  BTFSC  FC2.1
3AA4:  BRA    3AA2
3AA6:  MOVFF  FC4,03
3AAA:  MOVFF  FC3,3A
3AAE:  MOVFF  FC4,3B
3AB2:  CALL   2814
3AB6:  MOVFF  03,39
3ABA:  MOVFF  02,38
3ABE:  MOVFF  01,37
3AC2:  MOVFF  00,36
....................          delay_us(20); 
3AC6:  MOVLW  20
3AC8:  MOVWF  00
3ACA:  DECFSZ 00,F
3ACC:  BRA    3ACA
3ACE:  BRA    3AD0
3AD0:  NOP   
....................          y=read_adc(); 
3AD2:  BSF    FC2.1
3AD4:  BTFSC  FC2.1
3AD6:  BRA    3AD4
3AD8:  MOVFF  FC4,03
3ADC:  MOVFF  FC3,3A
3AE0:  MOVFF  FC4,3B
3AE4:  CALL   2814
3AE8:  MOVFF  03,35
3AEC:  MOVFF  02,34
3AF0:  MOVFF  01,33
3AF4:  MOVFF  00,32
....................           delay_us(20); 
3AF8:  MOVLW  20
3AFA:  MOVWF  00
3AFC:  DECFSZ 00,F
3AFE:  BRA    3AFC
3B00:  BRA    3B02
3B02:  NOP   
....................          y=(-0.17*valor)+171.4; 
3B04:  MOVLW  7B
3B06:  MOVWF  4A
3B08:  MOVLW  14
3B0A:  MOVWF  49
3B0C:  MOVLW  AE
3B0E:  MOVWF  48
3B10:  MOVLW  7C
3B12:  MOVWF  47
3B14:  MOVFF  39,4E
3B18:  MOVFF  38,4D
3B1C:  MOVFF  37,4C
3B20:  MOVFF  36,4B
3B24:  CALL   284A
3B28:  MOVFF  03,3D
3B2C:  MOVFF  02,3C
3B30:  MOVFF  01,3B
3B34:  MOVFF  00,3A
3B38:  BCF    FD8.1
3B3A:  MOVFF  03,41
3B3E:  MOVFF  02,40
3B42:  MOVFF  01,3F
3B46:  MOVFF  00,3E
3B4A:  MOVLW  66
3B4C:  MOVWF  45
3B4E:  MOVWF  44
3B50:  MOVLW  2B
3B52:  MOVWF  43
3B54:  MOVLW  86
3B56:  MOVWF  42
3B58:  CALL   2A96
3B5C:  MOVFF  03,35
3B60:  MOVFF  02,34
3B64:  MOVFF  01,33
3B68:  MOVFF  00,32
....................          y=y-15; 
3B6C:  BSF    FD8.1
3B6E:  MOVFF  35,41
3B72:  MOVFF  34,40
3B76:  MOVFF  33,3F
3B7A:  MOVFF  32,3E
3B7E:  CLRF   45
3B80:  CLRF   44
3B82:  MOVLW  70
3B84:  MOVWF  43
3B86:  MOVLW  82
3B88:  MOVWF  42
3B8A:  CALL   2A96
3B8E:  MOVFF  03,35
3B92:  MOVFF  02,34
3B96:  MOVFF  01,33
3B9A:  MOVFF  00,32
3B9E:  CLRF   19
3BA0:  BTFSC  FF2.7
3BA2:  BSF    19.7
3BA4:  BCF    FF2.7
....................          lcd_gotoxy(1,2); 
3BA6:  MOVLW  01
3BA8:  MOVWF  5B
3BAA:  MOVLW  02
3BAC:  MOVWF  5C
3BAE:  CALL   230C
3BB2:  BTFSC  19.7
3BB4:  BSF    FF2.7
....................          printf("Humedad= %.1f\r",y); 
3BB6:  MOVLW  E0
3BB8:  MOVWF  FF6
3BBA:  MOVLW  26
3BBC:  MOVWF  FF7
3BBE:  CLRF   19
3BC0:  BTFSC  FF2.7
3BC2:  BSF    19.7
3BC4:  BCF    FF2.7
3BC6:  MOVLW  09
3BC8:  MOVWF  54
3BCA:  CALL   20D2
3BCE:  BTFSC  19.7
3BD0:  BSF    FF2.7
3BD2:  MOVLW  89
3BD4:  MOVWF  FE9
3BD6:  MOVFF  35,3D
3BDA:  MOVFF  34,3C
3BDE:  MOVFF  33,3B
3BE2:  MOVFF  32,3A
3BE6:  MOVLW  01
3BE8:  MOVWF  3E
3BEA:  CALL   2DCC
3BEE:  MOVLW  0D
3BF0:  BTFSS  F9E.4
3BF2:  BRA    3BF0
3BF4:  MOVWF  FAD
....................          printf(lcd_putc,"Humedad= %.1f\r",y); 
3BF6:  MOVLW  F0
3BF8:  MOVWF  FF6
3BFA:  MOVLW  26
3BFC:  MOVWF  FF7
3BFE:  CLRF   19
3C00:  BTFSC  FF2.7
3C02:  BSF    19.7
3C04:  BCF    FF2.7
3C06:  MOVLW  09
3C08:  MOVWF  54
3C0A:  CALL   237E
3C0E:  BTFSC  19.7
3C10:  BSF    FF2.7
3C12:  MOVLW  89
3C14:  MOVWF  FE9
3C16:  MOVFF  35,3D
3C1A:  MOVFF  34,3C
3C1E:  MOVFF  33,3B
3C22:  MOVFF  32,3A
3C26:  MOVLW  01
3C28:  MOVWF  3E
3C2A:  CALL   2F4C
3C2E:  CLRF   19
3C30:  BTFSC  FF2.7
3C32:  BSF    19.7
3C34:  BCF    FF2.7
3C36:  MOVLW  0D
3C38:  MOVWF  5A
3C3A:  CALL   232E
3C3E:  BTFSC  19.7
3C40:  BSF    FF2.7
....................          delay_ms(500); 
3C42:  MOVLW  02
3C44:  MOVWF  3A
3C46:  CLRF   19
3C48:  BTFSC  FF2.7
3C4A:  BSF    19.7
3C4C:  BCF    FF2.7
3C4E:  MOVLW  FA
3C50:  MOVWF  5B
3C52:  CALL   20F2
3C56:  BTFSC  19.7
3C58:  BSF    FF2.7
3C5A:  DECFSZ 3A,F
3C5C:  BRA    3C46
3C5E:  BRA    38C8
....................          } 
....................          while(x<16){ 
3C60:  MOVFF  31,3D
3C64:  MOVFF  30,3C
3C68:  MOVFF  2F,3B
3C6C:  MOVFF  2E,3A
3C70:  CLRF   41
3C72:  CLRF   40
3C74:  CLRF   3F
3C76:  MOVLW  83
3C78:  MOVWF  3E
3C7A:  CALL   30FC
3C7E:  BTFSS  FD8.0
3C80:  BRA    3FF8
....................          output_high(PIN_A4);//CALEFACCION  
3C82:  BCF    F92.4
3C84:  BSF    F89.4
....................           output_low(PIN_A3);//VENTILADOR 
3C86:  BCF    F92.3
3C88:  BCF    F89.3
....................          output_low(PIN_A5);//BOMBA 
3C8A:  BCF    F92.5
3C8C:  BCF    F89.5
....................           set_adc_channel(0); 
3C8E:  MOVLW  00
3C90:  MOVWF  01
3C92:  MOVF   FC2,W
3C94:  ANDLW  C3
3C96:  IORWF  01,W
3C98:  MOVWF  FC2
3C9A:  CLRF   19
3C9C:  BTFSC  FF2.7
3C9E:  BSF    19.7
3CA0:  BCF    FF2.7
....................          delay_ms(10);              
3CA2:  MOVLW  0A
3CA4:  MOVWF  5B
3CA6:  CALL   20F2
3CAA:  BTFSC  19.7
3CAC:  BSF    FF2.7
....................           longdato= read_adc(); 
3CAE:  BSF    FC2.1
3CB0:  BTFSC  FC2.1
3CB2:  BRA    3CB0
3CB4:  MOVFF  FC3,2C
3CB8:  MOVFF  FC4,2D
....................          delay_us(20);        
3CBC:  MOVLW  20
3CBE:  MOVWF  00
3CC0:  DECFSZ 00,F
3CC2:  BRA    3CC0
3CC4:  BRA    3CC6
3CC6:  NOP   
....................           x= ((((float)longdato*5.0)/1023))*100;   
3CC8:  MOVFF  2D,3B
3CCC:  MOVFF  2C,3A
3CD0:  CALL   2814
3CD4:  MOVFF  03,3D
3CD8:  MOVFF  02,3C
3CDC:  MOVFF  01,3B
3CE0:  MOVFF  00,3A
3CE4:  MOVFF  03,4A
3CE8:  MOVFF  02,49
3CEC:  MOVFF  01,48
3CF0:  MOVFF  00,47
3CF4:  CLRF   4E
3CF6:  CLRF   4D
3CF8:  MOVLW  20
3CFA:  MOVWF  4C
3CFC:  MOVLW  81
3CFE:  MOVWF  4B
3D00:  CALL   284A
3D04:  MOVFF  03,3D
3D08:  MOVFF  02,3C
3D0C:  MOVFF  01,3B
3D10:  MOVFF  00,3A
3D14:  MOVFF  03,41
3D18:  MOVFF  02,40
3D1C:  MOVFF  01,3F
3D20:  MOVFF  00,3E
3D24:  CLRF   45
3D26:  MOVLW  C0
3D28:  MOVWF  44
3D2A:  MOVLW  7F
3D2C:  MOVWF  43
3D2E:  MOVLW  88
3D30:  MOVWF  42
3D32:  CALL   293C
3D36:  MOVFF  03,3D
3D3A:  MOVFF  02,3C
3D3E:  MOVFF  01,3B
3D42:  MOVFF  00,3A
3D46:  MOVFF  03,4A
3D4A:  MOVFF  02,49
3D4E:  MOVFF  01,48
3D52:  MOVFF  00,47
3D56:  CLRF   4E
3D58:  CLRF   4D
3D5A:  MOVLW  48
3D5C:  MOVWF  4C
3D5E:  MOVLW  85
3D60:  MOVWF  4B
3D62:  CALL   284A
3D66:  MOVFF  03,31
3D6A:  MOVFF  02,30
3D6E:  MOVFF  01,2F
3D72:  MOVFF  00,2E
....................          //delay_ms(200); 
....................          printf("Grados= %.1f\r",x); 
3D76:  MOVLW  00
3D78:  MOVWF  FF6
3D7A:  MOVLW  27
3D7C:  MOVWF  FF7
3D7E:  CLRF   19
3D80:  BTFSC  FF2.7
3D82:  BSF    19.7
3D84:  BCF    FF2.7
3D86:  MOVLW  08
3D88:  MOVWF  54
3D8A:  CALL   20D2
3D8E:  BTFSC  19.7
3D90:  BSF    FF2.7
3D92:  MOVLW  89
3D94:  MOVWF  FE9
3D96:  MOVFF  31,3D
3D9A:  MOVFF  30,3C
3D9E:  MOVFF  2F,3B
3DA2:  MOVFF  2E,3A
3DA6:  MOVLW  01
3DA8:  MOVWF  3E
3DAA:  CALL   2DCC
3DAE:  MOVLW  0D
3DB0:  BTFSS  F9E.4
3DB2:  BRA    3DB0
3DB4:  MOVWF  FAD
3DB6:  CLRF   19
3DB8:  BTFSC  FF2.7
3DBA:  BSF    19.7
3DBC:  BCF    FF2.7
....................           lcd_gotoxy(1,1); 
3DBE:  MOVLW  01
3DC0:  MOVWF  5B
3DC2:  MOVWF  5C
3DC4:  CALL   230C
3DC8:  BTFSC  19.7
3DCA:  BSF    FF2.7
....................          printf(lcd_putc,"Grados= %.1f\r",x); 
3DCC:  MOVLW  0E
3DCE:  MOVWF  FF6
3DD0:  MOVLW  27
3DD2:  MOVWF  FF7
3DD4:  CLRF   19
3DD6:  BTFSC  FF2.7
3DD8:  BSF    19.7
3DDA:  BCF    FF2.7
3DDC:  MOVLW  08
3DDE:  MOVWF  54
3DE0:  CALL   237E
3DE4:  BTFSC  19.7
3DE6:  BSF    FF2.7
3DE8:  MOVLW  89
3DEA:  MOVWF  FE9
3DEC:  MOVFF  31,3D
3DF0:  MOVFF  30,3C
3DF4:  MOVFF  2F,3B
3DF8:  MOVFF  2E,3A
3DFC:  MOVLW  01
3DFE:  MOVWF  3E
3E00:  CALL   2F4C
3E04:  CLRF   19
3E06:  BTFSC  FF2.7
3E08:  BSF    19.7
3E0A:  BCF    FF2.7
3E0C:  MOVLW  0D
3E0E:  MOVWF  5A
3E10:  CALL   232E
3E14:  BTFSC  19.7
3E16:  BSF    FF2.7
....................          set_adc_channel(1); 
3E18:  MOVLW  04
3E1A:  MOVWF  01
3E1C:  MOVF   FC2,W
3E1E:  ANDLW  C3
3E20:  IORWF  01,W
3E22:  MOVWF  FC2
3E24:  CLRF   19
3E26:  BTFSC  FF2.7
3E28:  BSF    19.7
3E2A:  BCF    FF2.7
....................          delay_ms(10); 
3E2C:  MOVLW  0A
3E2E:  MOVWF  5B
3E30:  CALL   20F2
3E34:  BTFSC  19.7
3E36:  BSF    FF2.7
....................          valor=read_adc(); 
3E38:  BSF    FC2.1
3E3A:  BTFSC  FC2.1
3E3C:  BRA    3E3A
3E3E:  MOVFF  FC4,03
3E42:  MOVFF  FC3,3A
3E46:  MOVFF  FC4,3B
3E4A:  CALL   2814
3E4E:  MOVFF  03,39
3E52:  MOVFF  02,38
3E56:  MOVFF  01,37
3E5A:  MOVFF  00,36
....................          delay_us(20); 
3E5E:  MOVLW  20
3E60:  MOVWF  00
3E62:  DECFSZ 00,F
3E64:  BRA    3E62
3E66:  BRA    3E68
3E68:  NOP   
....................          y=read_adc(); 
3E6A:  BSF    FC2.1
3E6C:  BTFSC  FC2.1
3E6E:  BRA    3E6C
3E70:  MOVFF  FC4,03
3E74:  MOVFF  FC3,3A
3E78:  MOVFF  FC4,3B
3E7C:  CALL   2814
3E80:  MOVFF  03,35
3E84:  MOVFF  02,34
3E88:  MOVFF  01,33
3E8C:  MOVFF  00,32
....................           delay_us(20); 
3E90:  MOVLW  20
3E92:  MOVWF  00
3E94:  DECFSZ 00,F
3E96:  BRA    3E94
3E98:  BRA    3E9A
3E9A:  NOP   
....................          y=(-0.17*valor)+171.4; 
3E9C:  MOVLW  7B
3E9E:  MOVWF  4A
3EA0:  MOVLW  14
3EA2:  MOVWF  49
3EA4:  MOVLW  AE
3EA6:  MOVWF  48
3EA8:  MOVLW  7C
3EAA:  MOVWF  47
3EAC:  MOVFF  39,4E
3EB0:  MOVFF  38,4D
3EB4:  MOVFF  37,4C
3EB8:  MOVFF  36,4B
3EBC:  CALL   284A
3EC0:  MOVFF  03,3D
3EC4:  MOVFF  02,3C
3EC8:  MOVFF  01,3B
3ECC:  MOVFF  00,3A
3ED0:  BCF    FD8.1
3ED2:  MOVFF  03,41
3ED6:  MOVFF  02,40
3EDA:  MOVFF  01,3F
3EDE:  MOVFF  00,3E
3EE2:  MOVLW  66
3EE4:  MOVWF  45
3EE6:  MOVWF  44
3EE8:  MOVLW  2B
3EEA:  MOVWF  43
3EEC:  MOVLW  86
3EEE:  MOVWF  42
3EF0:  CALL   2A96
3EF4:  MOVFF  03,35
3EF8:  MOVFF  02,34
3EFC:  MOVFF  01,33
3F00:  MOVFF  00,32
....................          y=y-15; 
3F04:  BSF    FD8.1
3F06:  MOVFF  35,41
3F0A:  MOVFF  34,40
3F0E:  MOVFF  33,3F
3F12:  MOVFF  32,3E
3F16:  CLRF   45
3F18:  CLRF   44
3F1A:  MOVLW  70
3F1C:  MOVWF  43
3F1E:  MOVLW  82
3F20:  MOVWF  42
3F22:  CALL   2A96
3F26:  MOVFF  03,35
3F2A:  MOVFF  02,34
3F2E:  MOVFF  01,33
3F32:  MOVFF  00,32
3F36:  CLRF   19
3F38:  BTFSC  FF2.7
3F3A:  BSF    19.7
3F3C:  BCF    FF2.7
....................          lcd_gotoxy(1,2); 
3F3E:  MOVLW  01
3F40:  MOVWF  5B
3F42:  MOVLW  02
3F44:  MOVWF  5C
3F46:  CALL   230C
3F4A:  BTFSC  19.7
3F4C:  BSF    FF2.7
....................          printf("Humedad= %.1f\r",y); 
3F4E:  MOVLW  1C
3F50:  MOVWF  FF6
3F52:  MOVLW  27
3F54:  MOVWF  FF7
3F56:  CLRF   19
3F58:  BTFSC  FF2.7
3F5A:  BSF    19.7
3F5C:  BCF    FF2.7
3F5E:  MOVLW  09
3F60:  MOVWF  54
3F62:  CALL   20D2
3F66:  BTFSC  19.7
3F68:  BSF    FF2.7
3F6A:  MOVLW  89
3F6C:  MOVWF  FE9
3F6E:  MOVFF  35,3D
3F72:  MOVFF  34,3C
3F76:  MOVFF  33,3B
3F7A:  MOVFF  32,3A
3F7E:  MOVLW  01
3F80:  MOVWF  3E
3F82:  CALL   2DCC
3F86:  MOVLW  0D
3F88:  BTFSS  F9E.4
3F8A:  BRA    3F88
3F8C:  MOVWF  FAD
....................          printf(lcd_putc,"Humedad= %.1f\r",y); 
3F8E:  MOVLW  2C
3F90:  MOVWF  FF6
3F92:  MOVLW  27
3F94:  MOVWF  FF7
3F96:  CLRF   19
3F98:  BTFSC  FF2.7
3F9A:  BSF    19.7
3F9C:  BCF    FF2.7
3F9E:  MOVLW  09
3FA0:  MOVWF  54
3FA2:  CALL   237E
3FA6:  BTFSC  19.7
3FA8:  BSF    FF2.7
3FAA:  MOVLW  89
3FAC:  MOVWF  FE9
3FAE:  MOVFF  35,3D
3FB2:  MOVFF  34,3C
3FB6:  MOVFF  33,3B
3FBA:  MOVFF  32,3A
3FBE:  MOVLW  01
3FC0:  MOVWF  3E
3FC2:  CALL   2F4C
3FC6:  CLRF   19
3FC8:  BTFSC  FF2.7
3FCA:  BSF    19.7
3FCC:  BCF    FF2.7
3FCE:  MOVLW  0D
3FD0:  MOVWF  5A
3FD2:  CALL   232E
3FD6:  BTFSC  19.7
3FD8:  BSF    FF2.7
....................          delay_ms(500); 
3FDA:  MOVLW  02
3FDC:  MOVWF  3A
3FDE:  CLRF   19
3FE0:  BTFSC  FF2.7
3FE2:  BSF    19.7
3FE4:  BCF    FF2.7
3FE6:  MOVLW  FA
3FE8:  MOVWF  5B
3FEA:  CALL   20F2
3FEE:  BTFSC  19.7
3FF0:  BSF    FF2.7
3FF2:  DECFSZ 3A,F
3FF4:  BRA    3FDE
3FF6:  BRA    3C60
....................     
....................          } 
3FF8:  GOTO   426A (RETURN)
....................    } 
....................    //----------------Invernadero manual 
....................    void controlmanualinv(){ 
....................    while(1){     
....................       if(kbhit()!=0){ 
3FFC:  MOVLW  00
3FFE:  BTFSC  F9E.5
4000:  MOVLW  01
4002:  XORLW  00
4004:  BZ    407A
....................       printf("\n\rCONTROL MANUAL INVERNADERO"); 
4006:  MOVLW  3C
4008:  MOVWF  FF6
400A:  MOVLW  27
400C:  MOVWF  FF7
400E:  CALL   27F2
....................       printf("\n\r 1) Ventilador");   
4012:  MOVLW  5A
4014:  MOVWF  FF6
4016:  MOVLW  27
4018:  MOVWF  FF7
401A:  CALL   27F2
....................       printf("\n\r 2) Calefactor"); 
401E:  MOVLW  6C
4020:  MOVWF  FF6
4022:  MOVLW  27
4024:  MOVWF  FF7
4026:  CALL   27F2
....................       printf("\n\r 3) Bomba"); 
402A:  MOVLW  7E
402C:  MOVWF  FF6
402E:  MOVLW  27
4030:  MOVWF  FF7
4032:  CALL   27F2
....................       printf("\n\r 4) Ventilador/Bomba"); 
4036:  MOVLW  8A
4038:  MOVWF  FF6
403A:  MOVLW  27
403C:  MOVWF  FF7
403E:  CALL   27F2
....................       printf("\n\r 5) Calefactor/Bomba"); 
4042:  MOVLW  A2
4044:  MOVWF  FF6
4046:  MOVLW  27
4048:  MOVWF  FF7
404A:  CALL   27F2
....................       printf("\n\r 6) Apagar todo"); 
404E:  MOVLW  BA
4050:  MOVWF  FF6
4052:  MOVLW  27
4054:  MOVWF  FF7
4056:  CALL   27F2
....................       printf("\n\r 8) Salir"); 
405A:  MOVLW  CC
405C:  MOVWF  FF6
405E:  MOVLW  27
4060:  MOVWF  FF7
4062:  CALL   27F2
....................       printf("\n\n\r Que deseas activar? "); 
4066:  MOVLW  D8
4068:  MOVWF  FF6
406A:  MOVLW  27
406C:  MOVWF  FF7
406E:  CALL   27F2
....................        tecla=getch();     
4072:  BTFSS  F9E.5
4074:  BRA    4072
4076:  MOVFF  FAE,2B
....................           } 
....................       switch(tecla){ 
407A:  MOVLW  31
407C:  SUBWF  2B,W
407E:  ADDLW  F8
4080:  BC    40DE
4082:  ADDLW  08
4084:  GOTO   40E4
....................       case'1':output_high(PIN_A3);//VENTILADOR 
4088:  BCF    F92.3
408A:  BSF    F89.3
....................       output_low(PIN_A4); 
408C:  BCF    F92.4
408E:  BCF    F89.4
....................       output_low(PIN_A5); 
4090:  BCF    F92.5
4092:  BCF    F89.5
....................       break; 
4094:  BRA    40DE
....................       case'2':output_high(PIN_A4);//CALEFACTOR 
4096:  BCF    F92.4
4098:  BSF    F89.4
....................       output_low(PIN_A3); 
409A:  BCF    F92.3
409C:  BCF    F89.3
....................       output_low(PIN_A5); 
409E:  BCF    F92.5
40A0:  BCF    F89.5
....................       break; 
40A2:  BRA    40DE
....................       case'3':output_high(PIN_A5);//BOMBA 
40A4:  BCF    F92.5
40A6:  BSF    F89.5
....................       output_low(PIN_A3); 
40A8:  BCF    F92.3
40AA:  BCF    F89.3
....................       output_low(PIN_A4); 
40AC:  BCF    F92.4
40AE:  BCF    F89.4
....................       break; 
40B0:  BRA    40DE
....................       case'4':output_high(PIN_A3);output_high(PIN_A5);//VENTILADOR/BOMBA 
40B2:  BCF    F92.3
40B4:  BSF    F89.3
40B6:  BCF    F92.5
40B8:  BSF    F89.5
....................       output_low(PIN_A5); 
40BA:  BCF    F92.5
40BC:  BCF    F89.5
....................       break; 
40BE:  BRA    40DE
....................       case'5':output_high(PIN_A4);output_high(PIN_A5);//CALEFACTOR/BOMBA 
40C0:  BCF    F92.4
40C2:  BSF    F89.4
40C4:  BCF    F92.5
40C6:  BSF    F89.5
....................       output_low(PIN_A3); 
40C8:  BCF    F92.3
40CA:  BCF    F89.3
....................       break; 
40CC:  BRA    40DE
....................       case'6':output_low(PIN_A3);output_low(PIN_A4);output_low(PIN_A5);break;//APAGA TODO 
40CE:  BCF    F92.3
40D0:  BCF    F89.3
40D2:  BCF    F92.4
40D4:  BCF    F89.4
40D6:  BCF    F92.5
40D8:  BCF    F89.5
40DA:  BRA    40DE
....................       case'8':return;break;//SALIR DEL SUBMENU 
40DC:  BRA    40E0
....................       } 
40DE:  BRA    3FFC
....................    } 
40E0:  GOTO   4290 (RETURN)
....................    } 

Configuration Fuses:
   Word  1: CC3F   PLL12 CPUDIV4 USBDIV HS FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
